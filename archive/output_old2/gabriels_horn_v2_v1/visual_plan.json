{
  "manim_code": "def construct(self):\n    # 1. HOOK: Title Animation\n    title = Text(\"Infinite Surface, Finite Volume?\", font_size=60)\n    self.play(Write(title))\n    self.wait(1.5)\n    \n    # Move title to top zone\n    self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n    \n    # 2. SETUP: Axes and Curve Definition\n    # Origin shifted left to allow room for the \"infinite\" tail\n    origin = np.array([-5, -1.0, 0])\n    \n    # Draw Axes manually with Lines/Arrows\n    x_axis = Arrow(start=origin + LEFT, end=origin + RIGHT * 10, buff=0, color=GRAY)\n    y_axis = Arrow(start=origin + DOWN * 2, end=origin + UP * 4, buff=0, color=GRAY)\n    x_label = Text(\"x\", font_size=36, color=GRAY).next_to(x_axis, DOWN)\n    y_label = Text(\"y\", font_size=36, color=GRAY).next_to(y_axis, LEFT)\n    \n    axis_group = VGroup(x_axis, y_axis, x_label, y_label)\n    self.play(FadeIn(axis_group))\n    \n    # Define points for the curve y = 1/x\n    # We scale it up visually: visual_y = 3 / actual_x\n    # visual_x moves from origin by actual_x * 1\n    points_top = []\n    points_bottom = []\n    \n    # Generate curve points\n    # x goes from 1 to 9 (representing 1 to infinity)\n    for x_val in np.arange(1.0, 9.0, 0.1):\n        visual_x = origin[0] + x_val\n        visual_y_top = origin[1] + (2.5 / x_val)\n        visual_y_bot = origin[1] - (2.5 / x_val)\n        points_top.append([visual_x, visual_y_top, 0])\n        points_bottom.append([visual_x, visual_y_bot, 0])\n        \n    # Create the top curve object\n    top_curve = VMobject(color=YELLOW, stroke_width=4)\n    top_curve.set_points_as_corners(points_top)\n    \n    # Label the curve\n    curve_label = Text(\"y = 1/x\", font_size=40, color=YELLOW)\n    curve_label.next_to(top_curve, UP, buff=0.1).shift(LEFT * 2)\n    \n    self.play(Create(top_curve), Write(curve_label))\n    self.wait(1)\n    \n    # 3. ROTATION: Show how the horn is formed\n    # Create a rotation indicator (curved arrow)\n    rotation_arrow = Arc(radius=0.5, start_angle=PI/2, angle=-PI, color=WHITE)\n    rotation_arrow.add_tip()\n    rotation_arrow.move_to(origin + np.array([1, 0, 0]))\n    rotation_text = Text(\"Rotate around x-axis\", font_size=32).next_to(rotation_arrow, DOWN)\n    \n    self.play(Create(rotation_arrow), Write(rotation_text))\n    self.wait(1)\n    \n    # Create the bottom curve (reflection)\n    bottom_curve = VMobject(color=YELLOW, stroke_width=4)\n    bottom_curve.set_points_as_corners(points_bottom)\n    \n    # Create ellipses to simulate 3D volume\n    # Ellipse at x=1 (start)\n    e1 = Ellipse(width=0.5, height=5.0, color=YELLOW_B).move_to(origin + np.array([1, 0, 0]))\n    # Ellipse at x=3\n    e2 = Ellipse(width=0.3, height=5.0/3.0, color=YELLOW_B).move_to(origin + np.array([3, 0, 0]))\n    # Ellipse at x=9 (end)\n    e3 = Ellipse(width=0.1, height=5.0/9.0, color=YELLOW_B).move_to(origin + np.array([9, 0, 0]))\n    \n    # Reveal the full horn shape\n    self.play(\n        Create(bottom_curve),\n        Create(e1),\n        Create(e2),\n        Create(e3),\n        FadeOut(rotation_arrow),\n        FadeOut(rotation_text)\n    )\n    \n    horn_group = VGroup(top_curve, bottom_curve, e1, e2, e3)\n    self.wait(1)\n    \n    # 4. VOLUME: Fill the inside\n    # Create a polygon to fill\n    fill_points = points_top + points_bottom[::-1]\n    horn_fill = Polygon(*fill_points, color=BLUE, fill_opacity=0.5, stroke_opacity=0)\n    \n    self.play(FadeIn(horn_fill))\n    \n    # Volume Text at bottom\n    vol_text_1 = Text(\"Volume = \u222b \u03c0(1/x)\u00b2 dx\", font_size=40).to_edge(DOWN, buff=0.9)\n    vol_text_2 = Text(\"Volume = \u03c0 (Finite)\", font_size=48, color=GREEN).to_edge(DOWN, buff=0.2)\n    \n    self.play(Write(vol_text_1))\n    self.wait(1.5)\n    self.play(Transform(vol_text_1, vol_text_2))\n    self.wait(2)\n    \n    # 5. SURFACE AREA: Highlight the outside\n    # Dim the fill, highlight stroke\n    self.play(horn_fill.animate.set_fill(opacity=0.2), horn_group.animate.set_color(RED))\n    \n    area_text_1 = Text(\"Area > \u222b 2\u03c0(1/x) dx\", font_size=40).to_edge(DOWN, buff=0.9)\n    # Note: Using different y position so it doesn't overlap if we kept previous (but we will replace)\n    area_text_2 = Text(\"Area = \u221e (Infinite)\", font_size=48, color=RED).to_edge(DOWN, buff=0.2)\n    \n    # Remove volume text, show area text\n    self.play(FadeOut(vol_text_1), FadeOut(vol_text_2))\n    self.play(Write(area_text_1))\n    self.wait(1.5)\n    self.play(Transform(area_text_1, area_text_2))\n    self.wait(2)\n    \n    # 6. PARADOX VISUALIZATION\n    # Clear bottom text for the paradox explanation\n    self.play(FadeOut(area_text_1))\n    \n    # Paint bucket metaphor\n    paint_emoji = Text(\"\ud83c\udfa8\", font_size=60).move_to(UP * 2.5 + RIGHT * 3)\n    paradox_1 = Text(\"Can fill inside with paint...\", font_size=36, color=GREEN).next_to(paint_emoji, DOWN)\n    paradox_2 = Text(\"...but can't paint the surface!\", font_size=36, color=RED).next_to(paradox_1, DOWN)\n    \n    self.play(FadeIn(paint_emoji))\n    self.play(Write(paradox_1))\n    self.play(horn_fill.animate.set_fill(opacity=0.8, color=GREEN)) # Fill with paint\n    self.wait(1)\n    \n    self.play(Write(paradox_2))\n    self.play(horn_group.animate.set_color(RED)) # Surface is infinite\n    self.wait(2.5)\n    \n    # 7. CONCLUSION: Morph everything to final result\n    final_statement = Text(\"V = \u03c0, S = \u221e\", font_size=80, color=YELLOW).move_to(ORIGIN)\n    \n    # Group everything currently visible\n    all_objects = VGroup(\n        title, axis_group, horn_group, horn_fill, curve_label, \n        paint_emoji, paradox_1, paradox_2\n    )\n    \n    self.play(ReplacementTransform(all_objects, final_statement), run_time=2.0)\n    self.wait(4)",
  "estimated_duration": 55
}