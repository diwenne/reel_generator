{
  "manim_code": "class GabrielsHorn(Scene):\n    def construct(self):\n        # 1. HOOK: Title Animation\n        title = Text(\"Infinite Surface Finite Volume?\", font_size=56)\n        title.move_to(ORIGIN)  # Start centered\n        self.play(Write(title))\n        self.wait(1.5)\n        \n        # Move title to top\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n\n        # 2. SETUP: Axes and Function\n        # Shift origin left to fit the long horn\n        origin_point = np.array([-5, -0.5, 0])\n        \n        # Create axes lines\n        x_axis = Line(start=origin_point, end=np.array([6, -0.5, 0]), color=GRAY)\n        y_axis = Line(start=np.array([-5, -3, 0]), end=np.array([-5, 2.5, 0]), color=GRAY)\n        x_label = Text(\"x\", font_size=24).next_to(x_axis, DOWN)\n        y_label = Text(\"y\", font_size=24).next_to(y_axis, LEFT)\n        \n        axes_group = VGroup(x_axis, y_axis, x_label, y_label)\n        self.play(FadeIn(axes_group))\n\n        # Manual Fraction Construction: y = 1/x\n        # x starts at 1 relative to our plot (x=0 is at -5, so x=1 is at -3 with scale 2)\n        # Let's define a scale. \n        # Visual scale: 1 unit in math = 2 units on screen\n        scale_factor = 2.0\n        \n        # Start x at math x=1 (screen x = -5 + 1*2 = -3)\n        # End x at math x=5.5 (screen x = -5 + 5.5*2 = 6) -> goes to edge\n        \n        def get_horn_point(math_x, sign=1):\n            screen_x = origin_point[0] + math_x * scale_factor\n            # y = 1/x\n            math_y = (1.0 / math_x) * sign\n            screen_y = origin_point[1] + math_y * scale_factor\n            return np.array([screen_x, screen_y, 0])\n\n        # Create the visual fraction label\n        frac_num = Text(\"1\", font_size=40)\n        frac_line = Line(LEFT, RIGHT, width=0.6).set_stroke(width=2)\n        frac_den = Text(\"x\", font_size=40)\n        fraction = VGroup(frac_num, frac_line, frac_den).arrange(DOWN, buff=0.1)\n        \n        # Equation label \"y = \"\n        eq_prefix = Text(\"y =\", font_size=40)\n        equation_group = VGroup(eq_prefix, fraction).arrange(RIGHT, buff=0.2)\n        equation_group.next_to(origin_point, UP, buff=1.5).shift(RIGHT * 2)\n        \n        self.play(Write(equation_group))\n        self.wait(1)\n\n        # 3. DRAW CURVE y = 1/x\n        # We approximate the curve with many small line segments\n        top_points = []\n        bottom_points = []\n        x_values = np.linspace(1, 5.5, 100)\n        \n        for x_val in x_values:\n            top_points.append(get_horn_point(x_val, 1))\n            bottom_points.append(get_horn_point(x_val, -1))\n            \n        top_curve = VMobject().set_points_smoothly(top_points).set_color(BLUE)\n        bottom_curve = VMobject().set_points_smoothly(bottom_points).set_color(BLUE)\n        \n        # Animate drawing the top curve\n        self.play(Create(top_curve), run_time=2)\n        self.wait(1)\n\n        # 4. ROTATION (Create Horn)\n        rot_text = Text(\"Rotate around x-axis\", font_size=32, color=BLUE_B)\n        rot_text.next_to(equation_group, DOWN, buff=0.5)\n        self.play(Write(rot_text))\n        \n        # Show mirror image\n        self.play(TransformFromCopy(top_curve, bottom_curve))\n        \n        # Draw opening ellipse to simulate 3D\n        # Ellipse at x=1\n        p1_top = get_horn_point(1, 1)\n        p1_bot = get_horn_point(1, -1)\n        height_at_1 = p1_top[1] - p1_bot[1]\n        opening = Ellipse(width=0.5, height=height_at_1, color=BLUE_A)\n        opening.move_to(np.array([p1_top[0], origin_point[1], 0]))\n        \n        # Ellipse at end (x=5.5) - very small\n        p_end_top = get_horn_point(5.5, 1)\n        p_end_bot = get_horn_point(5.5, -1)\n        height_at_end = p_end_top[1] - p_end_bot[1]\n        closing = Ellipse(width=0.1, height=height_at_end, color=BLUE_A)\n        closing.move_to(np.array([p_end_top[0], origin_point[1], 0]))\n        \n        horn_group = VGroup(top_curve, bottom_curve, opening, closing)\n        self.play(Create(opening), Create(closing))\n        self.play(FadeOut(rot_text))\n        self.wait(1)\n\n        # 5. VOLUME (Finite)\n        # Create a filled polygon for volume\n        volume_points = list(top_points) + list(reversed(bottom_points))\n        horn_fill = Polygon(*volume_points, color=GREEN, fill_opacity=0.5, stroke_width=0)\n        \n        vol_label = Text(\"Volume = \u03c0\", font_size=44, color=GREEN)\n        vol_label.move_to(UP * 2 + RIGHT * 2)\n        \n        paint_text = Text(\"Finite paint to fill\", font_size=36, color=GREEN_B)\n        paint_text.next_to(vol_label, DOWN)\n        \n        self.play(FadeIn(horn_fill))\n        self.play(Write(vol_label))\n        self.play(Write(paint_text))\n        self.wait(2)\n\n        # 6. SURFACE AREA (Infinite)\n        # Highlight the boundary\n        surf_label = Text(\"Surface Area = \u221e\", font_size=44, color=RED)\n        surf_label.next_to(paint_text, DOWN, buff=0.8)\n        \n        cant_paint = Text(\"Impossible to paint!\", font_size=36, color=RED_B)\n        cant_paint.next_to(surf_label, DOWN)\n        \n        # Pulse the boundary lines red\n        self.play(\n            top_curve.animate.set_color(RED).set_stroke(width=5),\n            bottom_curve.animate.set_color(RED).set_stroke(width=5),\n            run_time=1.5\n        )\n        self.play(Write(surf_label))\n        self.play(Write(cant_paint))\n        self.wait(2)\n\n        # 7. PARADOX REVEAL\n        # Move labels to clear center for a moment or just highlight the contradiction\n        paradox_text = Text(\"The Paradox\", font_size=48, color=YELLOW)\n        paradox_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(paradox_text))\n        self.wait(2)\n\n        # 8. CONCLUSION\n        # Create final destination text\n        final_statment = Text(\"V = \u03c0, S = \u221e\", font_size=72, color=YELLOW)\n        final_statment.move_to(ORIGIN)\n\n        # Group everything currently visible\n        all_objects = VGroup(\n            title, axes_group, equation_group, \n            horn_group, horn_fill, \n            vol_label, paint_text, surf_label, cant_paint, paradox_text\n        )\n\n        # Morph everything into the final equation\n        self.play(ReplacementTransform(all_objects, final_statment), run_time=2.0)\n        \n        # Final hold\n        self.wait(3)\n",
  "estimated_duration": 50
}