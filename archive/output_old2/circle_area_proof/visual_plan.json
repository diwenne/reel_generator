{
  "manim_code": "title = Text(\"Area of a Circle: Visual Proof\", font_size=42)\ntitle.to_edge(UP, buff=0.5)\nself.play(Write(title), run_time=1.0)\nself.wait(0.5)\n\n# SECTION 1: SETUP\n# Create the main circle and radius\nR = 2.0\ncircle_center = LEFT * 0\nmain_circle = Circle(radius=R, color=BLUE, fill_opacity=0.2)\nmain_circle.move_to(circle_center)\n\nradius_line = Line(start=main_circle.get_center(), end=main_circle.get_right(), color=YELLOW)\nradius_label = Text(\"r\", font_size=32, color=YELLOW)\nradius_label.next_to(radius_line, UP, buff=0.1)\n\nself.play(Create(main_circle), run_time=1.0)\nself.play(Create(radius_line), Write(radius_label), run_time=1.0)\nself.wait(1.0)\n\n# Create the question text\nquestion = Text(\"Area = ?\", font_size=36)\nquestion.move_to(DOWN * 2.5)\nself.play(Write(question))\nself.wait(1.0)\n\n# SECTION 2: SLICING\n# Replace circle with wedges\nnum_wedges = 24\nangle_per_wedge = TAU / num_wedges\nwedges = VGroup()\n\nfor i in range(num_wedges):\n    wedge = AnnularSector(\n        inner_radius=0,\n        outer_radius=R,\n        angle=angle_per_wedge,\n        start_angle=i * angle_per_wedge,\n        color=BLUE if i % 2 == 0 else TEAL,\n        fill_opacity=0.8,\n        stroke_width=1,\n        stroke_color=WHITE\n    )\n    wedges.add(wedge)\n\nwedges.move_to(circle_center)\n\n# Smooth transition from circle to wedges\nself.play(\n    FadeOut(main_circle), \n    FadeOut(radius_line),\n    FadeOut(radius_label),\n    FadeIn(wedges),\n    run_time=1.0\n)\n\nexplain_slice = Text(\"Slice into sectors\", font_size=32, color=GREY_A)\nexplain_slice.next_to(question, UP, buff=0.5)\nself.play(Write(explain_slice), run_time=1.0)\nself.wait(1.0)\n\n# SECTION 3: REARRANGE\n# Remove old text to clear space\nself.play(\n    FadeOut(question),\n    FadeOut(explain_slice),\n    run_time=0.5\n)\n\n# Create the target rectangular arrangement\nrect_wedges = VGroup()\ntotal_width = PI * R  # Half circumference\nwedge_width = total_width / (num_wedges / 2) # Approximate linear spacing\n\n# Start position (centered horizontally)\nstart_x = -total_width / 2 + (wedge_width / 4)\n\nfor i in range(num_wedges):\n    # Create a copy to transform\n    target_wedge = wedges[i].copy()\n    \n    # Rotate: Even point UP (90deg), Odd point DOWN (-90deg)\n    # Note: AnnularSector starts centered at circle origin. \n    # Rotating it pivots around that origin (the pointy tip).\n    if i % 2 == 0:\n        target_wedge.rotate(PI/2 - (i * angle_per_wedge), about_point=ORIGIN)\n        # Even wedges (UP) sit at the bottom\n        target_y = -R/2\n    else:\n        target_wedge.rotate(-PI/2 - (i * angle_per_wedge), about_point=ORIGIN)\n        # Odd wedges (DOWN) sit at the top to interlock\n        target_y = R/2\n    \n    # Calculate X position\n    # We place them sequentially. Since they interlock, we step by half width roughly\n    target_x = start_x + (i * (wedge_width / 2))\n    \n    # Move to final position\n    target_wedge.move_to(np.array([target_x, target_y, 0]), aligned_edge=ORIGIN)\n    # The 'aligned_edge=ORIGIN' is tricky with sectors. \n    # Instead, let's manually shift by the anchor point difference.\n    # The anchor of the sector (0,0) is now rotated.\n    # We simply want the TIPS to align along y=0 roughly.\n    # With the rotation above, the tip is at the object's center.\n    # So we just move that center.\n    target_wedge.move_to(np.array([target_x, 0, 0]) + UP * (target_y/abs(target_y) * -R/2))\n    # Correction: If i is even (points UP), tip is down. Center of geometry is higher.\n    # Simpler approach: Just shift based on observation.\n    # Even (Up): Tip at bottom. Odd (Down): Tip at top.\n    # We want tips to touch at y=0.\n    if i % 2 == 0:\n        target_wedge.move_to(np.array([target_x, 0, 0]), coor_mask=np.array([1, 0, 0])) # Keep X\n        target_wedge.shift(UP * R/2) # Move center up so tip (which is R away?) No.\n        # Let's use the known bounding box.\n        target_wedge.move_to(np.array([target_x, -R/2, 0]), aligned_edge=DOWN)\n    else:\n        target_wedge.move_to(np.array([target_x, R/2, 0]), aligned_edge=UP)\n        \n    rect_wedges.add(target_wedge)\n\n# Center the whole group\nrect_wedges.move_to(ORIGIN)\n\n# Execute the transformation\nself.play(Transform(wedges, rect_wedges), run_time=2.0)\nself.wait(1.0)\n\n# SECTION 4: LABELS & LOGIC\n# Add braces to the \"Rectangle\"\n# The height is R\nbrace_r = Brace(rect_wedges, RIGHT, buff=0.2)\nlabel_r = Text(\"r\", font_size=32, color=YELLOW).next_to(brace_r, RIGHT, buff=0.2)\n\n# The width is half circumference (pi * r)\nbrace_w = Brace(rect_wedges, DOWN, buff=0.2)\nlabel_w = Text(\"\u03c0r\", font_size=32, color=YELLOW).next_to(brace_w, DOWN, buff=0.2)\n\nself.play(Create(brace_r), Write(label_r), run_time=1.0)\nself.play(Create(brace_w), Write(label_w), run_time=1.0)\nself.wait(1.0)\n\n# SECTION 5: CONCLUSION\n# Show formula building\ntext_group = VGroup(\n    Text(\"Area \u2248 Base \u00d7 Height\", font_size=36),\n    Text(\"Area = \u03c0r \u00d7 r\", font_size=36),\n    Text(\"Area = \u03c0r\u00b2\", font_size=48, color=GREEN)\n).arrange(DOWN, buff=0.5)\n\n# Position text in the clear space below (or clear screen)\n# Let's clear the braces to make room for big conclusion\nself.play(\n    FadeOut(brace_r), FadeOut(label_r),\n    FadeOut(brace_w), FadeOut(label_w),\n    rect_wedges.animate.shift(UP * 1.0),\n    run_time=1.0\n)\n\ntext_group.next_to(rect_wedges, DOWN, buff=1.0)\n\nself.play(Write(text_group[0]), run_time=1.0)\nself.wait(1.0)\nself.play(TransformMatchingShapes(text_group[0].copy(), text_group[1]), run_time=1.0)\nself.wait(1.0)\nself.play(TransformMatchingShapes(text_group[1], text_group[2]), run_time=1.5)\nself.wait(3.0)",
  "estimated_duration": 60
}