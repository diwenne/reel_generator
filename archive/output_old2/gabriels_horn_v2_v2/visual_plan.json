{
  "manim_code": "from manim import *\n\nclass GabrielsHorn(Scene):\n    def construct(self):\n        # 1. Intro Title\n        # Start at CENTER (ORIGIN) then move UP\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n\n        # 2. Setup Axes\n        # Define origin manually to ensure precise placement\n        origin = LEFT * 4 + DOWN * 1\n        # Lambda to map math coordinates to screen coordinates\n        # x: 1 unit = 0.8 screen units, y: 1 unit = 1.5 screen units\n        get_point = lambda x, y: origin + RIGHT * (x * 0.8) + UP * (y * 1.5)\n\n        x_axis = Arrow(start=origin, end=origin + RIGHT * 9, buff=0, color=GRAY)\n        y_axis = Line(start=origin + DOWN * 2, end=origin + UP * 2.5, color=GRAY)\n        \n        x_label = Text(\"x\", font_size=24).next_to(x_axis, DOWN)\n        y_label = Text(\"y\", font_size=24).next_to(y_axis, LEFT)\n        \n        axis_group = VGroup(x_axis, y_axis, x_label, y_label)\n        self.play(FadeIn(axis_group))\n\n        # 3. Draw the curve y = 1/x\n        # Create points for top curve (x from 1 to 10)\n        curve_points = []\n        for i in range(0, 101):\n            val_x = 1 + (9 * i / 100) # x goes 1 to 10\n            val_y = 1 / val_x\n            curve_points.append(get_point(val_x, val_y))\n            \n        top_curve = VMobject(color=BLUE, stroke_width=4)\n        top_curve.set_points_smoothly(curve_points)\n        \n        curve_label = Text(\"y = 1/x\", font_size=36, color=BLUE)\n        curve_label.next_to(top_curve.get_start(), UP + RIGHT, buff=0.1)\n\n        self.play(Create(top_curve), Write(curve_label))\n        self.wait(1)\n\n        # 4. Create the Horn (Rotation)\n        # Mirror for bottom curve\n        bottom_points = []\n        for i in range(0, 101):\n            val_x = 1 + (9 * i / 100)\n            val_y = -1 / val_x\n            bottom_points.append(get_point(val_x, val_y))\n            \n        bottom_curve = VMobject(color=BLUE, stroke_width=4)\n        bottom_curve.set_points_smoothly(bottom_points)\n\n        # Create ellipses to simulate 3D rotation\n        # Start Ellipse (x=1)\n        p1_top = get_point(1, 1)\n        p1_bot = get_point(1, -1)\n        center_1 = get_point(1, 0)\n        height_1 = p1_top[1] - p1_bot[1]\n        e1 = Ellipse(width=0.4, height=height_1, color=BLUE_E).move_to(center_1)\n        \n        # Mid Ellipse (x=3)\n        p3_top = get_point(3, 1/3)\n        p3_bot = get_point(3, -1/3)\n        center_3 = get_point(3, 0)\n        height_3 = p3_top[1] - p3_bot[1]\n        e2 = Ellipse(width=0.2, height=height_3, color=BLUE_E).move_to(center_3)\n\n        # End Ellipse (x=10)\n        p10_top = get_point(10, 1/10)\n        p10_bot = get_point(10, -1/10)\n        center_10 = get_point(10, 0)\n        height_10 = p10_top[1] - p10_bot[1]\n        e3 = Ellipse(width=0.1, height=height_10, color=BLUE_E).move_to(center_10)\n\n        rotate_text = Text(\"Rotate around x-axis\", font_size=36, color=YELLOW).to_edge(DOWN, buff=1.0)\n\n        self.play(\n            Create(bottom_curve),\n            Create(e1), Create(e2), Create(e3),\n            Write(rotate_text)\n        )\n        self.wait(1)\n        self.play(FadeOut(rotate_text))\n\n        # Create a filled shape for the horn volume\n        horn_poly_points = curve_points + bottom_points[::-1]\n        horn_fill = Polygon(*horn_poly_points, stroke_width=0, fill_color=BLUE, fill_opacity=0.3)\n        self.play(FadeIn(horn_fill))\n        \n        # 5. Volume Logic\n        # Change color to GREEN to emphasize interior\n        vol_label = Text(\"Volume: Sum of Slices\", font_size=40).to_edge(DOWN, buff=1.0)\n        self.play(horn_fill.animate.set_color(GREEN), Write(vol_label))\n        \n        # Formula: Area = pi * r^2 = pi * (1/x)^2\n        slice_formula = Text(\"Slice Area = \u03c0(1/x)\u00b2 = \u03c0/x\u00b2\", font_size=36, color=GREEN_B)\n        slice_formula.next_to(vol_label, UP, buff=0.3)\n        self.play(Write(slice_formula))\n        self.wait(2)\n        \n        # Convergence result\n        conv_text = Text(\"Sum of 1/x\u00b2 is Finite\", font_size=40, color=GREEN)\n        conv_text.move_to(vol_label.get_center())\n        \n        finite_res = Text(\"Total Volume = \u03c0\", font_size=48, color=GREEN)\n        finite_res.next_to(conv_text, DOWN)\n        \n        self.play(\n            Transform(vol_label, conv_text),\n            FadeOut(slice_formula)\n        )\n        self.play(Write(finite_res))\n        self.wait(2)\n        \n        # Store result and clear for next section\n        vol_summary = Text(\"V = \u03c0\", font_size=40, color=GREEN).move_to(UP*2.0 + RIGHT*3.5)\n        self.play(\n            FadeOut(vol_label),\n            FadeOut(finite_res),\n            Transform(horn_fill, horn_fill.copy().set_color(BLUE).set_opacity(0.1)),\n            Write(vol_summary)\n        )\n\n        # 6. Surface Area Logic\n        # Highlight edges RED\n        surf_label = Text(\"Surface: Sum of Rings\", font_size=40).to_edge(DOWN, buff=1.0)\n        self.play(\n            top_curve.animate.set_color(RED),\n            bottom_curve.animate.set_color(RED),\n            Write(surf_label)\n        )\n        \n        # Formula: Circumference = 2*pi*r = 2*pi/x\n        ring_formula = Text(\"Circumference = 2\u03c0(1/x)\", font_size=36, color=RED_B)\n        ring_formula.next_to(surf_label, UP, buff=0.3)\n        self.play(Write(ring_formula))\n        self.wait(2)\n        \n        # Divergence result\n        div_text = Text(\"Sum of 1/x is Infinite\", font_size=40, color=RED)\n        div_text.move_to(surf_label.get_center())\n        \n        inf_res = Text(\"Total Surface = \u221e\", font_size=48, color=RED)\n        inf_res.next_to(div_text, DOWN)\n        \n        self.play(\n            Transform(surf_label, div_text),\n            FadeOut(ring_formula)\n        )\n        self.play(Write(inf_res))\n        self.wait(2)\n\n        # Store result\n        surf_summary = Text(\"S = \u221e\", font_size=40, color=RED).next_to(vol_summary, DOWN, buff=0.3)\n        self.play(\n            FadeOut(surf_label),\n            FadeOut(inf_res),\n            Write(surf_summary)\n        )\n\n        # 7. The Paradox Conclusion\n        paradox_1 = Text(\"Finite paint to fill...\", font_size=44, color=YELLOW)\n        paradox_2 = Text(\"...but infinite paint to coat!\", font_size=44, color=YELLOW)\n        \n        # Group and position carefully at bottom\n        paradox_group = VGroup(paradox_1, paradox_2).arrange(DOWN).to_edge(DOWN, buff=0.5)\n        \n        self.play(Write(paradox_1))\n        self.wait(1.5)\n        self.play(Write(paradox_2))\n        self.wait(2.5)\n\n        # 8. Final Morph\n        final_eq = Text(\"V = \u03c0,   S = \u221e\", font_size=72, color=YELLOW).move_to(ORIGIN)\n        \n        all_objects = VGroup(\n            title, axis_group, top_curve, bottom_curve, curve_label,\n            e1, e2, e3, horn_fill, vol_summary, surf_summary,\n            paradox_1, paradox_2\n        )\n        \n        self.play(ReplacementTransform(all_objects, final_eq), run_time=2.0)\n        self.wait(3)",
  "estimated_duration": 58
}