{
  "manim_code": "class GabrielsHorn(Scene):\n    def construct(self):\n        # 1. INTRO TITLE\n        # Start centered, then move up\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n\n        # 2. EQUATION (Manually built fraction)\n        # \"y = 1/x\" centered\n        y_eq = Text(\"y =\", font_size=60)\n        num = Text(\"1\", font_size=60)\n        bar = Line(LEFT, RIGHT, color=WHITE).set_length(0.6)\n        den = Text(\"x\", font_size=60)\n        frac = VGroup(num, bar, den).arrange(DOWN, buff=0.15)\n        \n        equation_group = VGroup(y_eq, frac).arrange(RIGHT, buff=0.3).move_to(ORIGIN)\n        \n        self.play(Write(equation_group))\n        self.wait(2)\n\n        # 3. GRAPH & HORN VISUALIZATION\n        # Move equation aside or fade it to make room for graph\n        self.play(FadeOut(equation_group))\n\n        # Define axes\n        # x from 0 to 10, y from -3 to 3\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-3, 3, 1],\n            x_length=10,\n            y_length=5,\n            axis_config={\"include_tip\": True, \"color\": GREY},\n        ).move_to(DOWN * 0.5)\n        \n        x_label = Text(\"x\", font_size=36).next_to(axes.x_axis, DOWN)\n        \n        # The curve 1/x starting at x=1\n        curve_top = axes.plot(lambda x: 1/x, x_range=[1, 9], color=BLUE, stroke_width=4)\n        curve_label = Text(\"y = 1/x\", font_size=36, color=BLUE).next_to(curve_top.get_start(), UP)\n\n        self.play(Create(axes), Write(x_label))\n        self.play(Create(curve_top), Write(curve_label))\n        self.wait(1)\n\n        # Create the 'Horn' by mirroring the curve and filling\n        curve_bottom = axes.plot(lambda x: -1/x, x_range=[1, 9], color=BLUE, stroke_width=4)\n        \n        # Area representing the horn volume\n        horn_area = axes.get_area(curve_top, x_range=[1, 9], bounded_graph=curve_bottom, color=YELLOW, opacity=0.5)\n        \n        # Ellipses to simulate 3D rotation (disks)\n        # Just a few visual rings to imply the 3D shape\n        rings = VGroup()\n        for x_val in [1, 2, 4, 8]:\n            height = 2.0 / x_val\n            # Map coordinates to scene\n            pos = axes.c2p(x_val, 0)\n            # Calculate height in scene units\n            top_pt = axes.c2p(x_val, 1/x_val)\n            bottom_pt = axes.c2p(x_val, -1/x_val)\n            scene_h = top_pt[1] - bottom_pt[1]\n            ellipse = Ellipse(width=0.3, height=scene_h, color=WHITE, stroke_width=2).move_to(pos)\n            rings.add(ellipse)\n\n        self.play(\n            Create(curve_bottom),\n            FadeIn(horn_area),\n            Create(rings),\n            run_time=2\n        )\n        self.wait(1)\n\n        # Move everything up slightly to make room for math below\n        graph_group = VGroup(axes, x_label, curve_top, curve_label, curve_bottom, horn_area, rings)\n        self.play(graph_group.animate.shift(UP * 0.5))\n\n        # 4. VOLUME CALCULATION\n        # Math constraints: NO LaTeX. Use Text only. Bottom zone.\n        \n        # Line 1: Integral formula\n        vol_text_1 = Text(\"Volume: \u03c0 \u222b (1/x)\u00b2 dx\", font_size=40).to_edge(DOWN, buff=1.8)\n        # Use separate text for limits to place them somewhat correctly or just imply them with text\n        # Simplified for readability as requested\n        \n        self.play(Write(vol_text_1))\n        self.wait(1.5)\n\n        # Line 2: Result of integral\n        vol_text_2 = Text(\"Integral converges to 1\", font_size=40).next_to(vol_text_1, DOWN, buff=0.2)\n        self.play(Write(vol_text_2))\n        self.wait(1.5)\n\n        # Line 3: Final volume\n        vol_result = Text(\"Volume = \u03c0\", font_size=48, color=GREEN).next_to(vol_text_2, DOWN, buff=0.2)\n        self.play(Write(vol_result))\n        self.wait(2)\n\n        # Clear volume text for surface area text\n        volume_group = VGroup(vol_text_1, vol_text_2, vol_result)\n        self.play(FadeOut(volume_group))\n\n        # 5. SURFACE AREA CALCULATION\n        # Line 1: Formula\n        sa_text_1 = Text(\"Area: 2\u03c0 \u222b (1/x)\u221a(1+...) dx\", font_size=40).to_edge(DOWN, buff=1.8)\n        self.play(Write(sa_text_1))\n        self.wait(1.5)\n\n        # Line 2: Divergence\n        sa_text_2 = Text(\"Integral diverges\", font_size=40).next_to(sa_text_1, DOWN, buff=0.2)\n        self.play(Write(sa_text_2))\n        self.wait(1.5)\n\n        # Line 3: Final Area\n        sa_result = Text(\"Surface Area = \u221e\", font_size=48, color=RED).next_to(sa_text_2, DOWN, buff=0.2)\n        self.play(Write(sa_result))\n        self.wait(2)\n\n        # 6. INTERPRETATION\n        sa_group = VGroup(sa_text_1, sa_text_2, sa_result)\n        self.play(FadeOut(sa_group))\n\n        paradox_text = Text(\"Finite Volume \u2260 Finite Area\", font_size=48).to_edge(DOWN, buff=1.0)\n        self.play(Write(paradox_text))\n        self.wait(3)\n\n        # 7. FINAL MORPH\n        # Gather everything\n        all_objects = VGroup(title, graph_group, paradox_text)\n        \n        # Final screen elements\n        final_title = Text(\"Gabriel's Horn\", font_size=72, color=BLUE).shift(UP * 1)\n        final_stats = Text(\"V = \u03c0      Area = \u221e\", font_size=60, color=YELLOW).next_to(final_title, DOWN, buff=0.5)\n        final_group = VGroup(final_title, final_stats).move_to(ORIGIN)\n\n        self.play(ReplacementTransform(all_objects, final_group), run_time=2)\n        self.wait(3)",
  "estimated_duration": 50
}