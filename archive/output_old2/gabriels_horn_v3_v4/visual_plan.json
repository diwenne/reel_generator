{
  "manim_code": "from manim import *\nimport numpy as np\n\nclass GabrielsHorn(Scene):\n    def construct(self):\n        # 1. HOOK: Title starts at CENTER, then animates UP\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        # Animate title to top\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n\n        # 2. SETUP: Axes and Function\n        # Define coordinate system manually for full control\n        origin = np.array([-5, -1.5, 0])\n        unit_size = 1.8  # Scale factor\n        \n        # Axis lines\n        x_axis = Arrow(start=origin + LEFT, end=origin + RIGHT * 10, color=GRAY)\n        y_axis = Arrow(start=origin + DOWN, end=origin + UP * 4, color=GRAY)\n        x_label = Text(\"x\", font_size=36).next_to(x_axis, DOWN)\n        y_label = Text(\"y\", font_size=36).next_to(y_axis, LEFT)\n        \n        axes_group = VGroup(x_axis, y_axis, x_label, y_label)\n        self.play(Create(axes_group))\n        \n        # Create the visual Fraction \"y = 1/x\"\n        # \"proper FRACTION with 1 on top and x on bottom\"\n        frac_num = Text(\"1\", font_size=40)\n        frac_line = Line(LEFT*0.3, RIGHT*0.3).next_to(frac_num, DOWN, buff=0.1)\n        frac_den = Text(\"x\", font_size=40).next_to(frac_line, DOWN, buff=0.1)\n        frac_eq = Text(\"y =\", font_size=40).next_to(frac_line, LEFT, buff=0.2)\n        \n        # Group them properly for alignment\n        func_label = VGroup(frac_eq, frac_num, frac_line, frac_den)\n        func_label.move_to(origin + UP * 3 + RIGHT * 2)\n        \n        self.play(Write(func_label))\n        \n        # Draw the curve y = 1/x from x=1 to x=6 (representing infinity)\n        # Screen coordinates calculation: P = origin + x*unit*RIGHT + y*unit*UP\n        \n        # Generate points for top curve\n        x_values = np.linspace(1, 6, 100)\n        top_points = [\n            origin + (x * unit_size * RIGHT) + ((1/x) * unit_size * UP)\n            for x in x_values\n        ]\n        top_curve = VMobject(color=BLUE, stroke_width=4).set_points_smoothly(top_points)\n        \n        # Mark x=1 line\n        start_line = DashedLine(\n            origin + 1 * unit_size * RIGHT,\n            origin + 1 * unit_size * RIGHT + 1 * unit_size * UP,\n            color=GRAY\n        )\n        start_label = Text(\"x=1\", font_size=32).next_to(start_line, DOWN, buff=0.2)\n        \n        self.play(Create(start_line), Write(start_label))\n        self.play(Create(top_curve), run_time=2)\n        self.wait(1)\n\n        # 3. ROTATION: Create the Horn Shape (2D Silhouette)\n        # Generate points for bottom curve (y = -1/x)\n        bottom_points = [\n            origin + (x * unit_size * RIGHT) - ((1/x) * unit_size * UP)\n            for x in x_values\n        ]\n        bottom_curve = VMobject(color=BLUE, stroke_width=4).set_points_smoothly(bottom_points)\n        \n        # Create the filled shape (horn)\n        horn_points = top_points + bottom_points[::-1]\n        horn_fill = Polygon(*horn_points, color=BLUE, fill_opacity=0.3, stroke_width=0)\n        \n        # Rotation indicator text\n        rotation_text = Text(\"Rotate around x-axis\", font_size=36, color=YELLOW)\n        rotation_text.to_edge(DOWN, buff=1.0)\n        \n        self.play(Write(rotation_text))\n        self.play(\n            TransformFromCopy(top_curve, bottom_curve),\n            FadeIn(horn_fill),\n            run_time=2\n        )\n        self.wait(1)\n        self.play(FadeOut(rotation_text))\n\n        # 4. VOLUME (Finite)\n        # Visualizing volume as disks\n        volume_label = Text(\"Volume\", font_size=40, color=GREEN).move_to(rotation_text.get_center() + UP*0.5)\n        volume_value = Text(\"V = \u03c0\", font_size=60, color=GREEN).next_to(volume_label, DOWN)\n        \n        # Animate filling the volume\n        fill_rect = Rectangle(width=0.1, height=4, color=GREEN, fill_opacity=0.8)\n        fill_rect.move_to(origin + RIGHT)\n        \n        # Scan effect from left to right inside the horn\n        self.play(Write(volume_label))\n        \n        # Just show the result clearly\n        self.play(Write(volume_value))\n        self.wait(2)\n        \n        # Move volume text aside to make room\n        vol_group = VGroup(volume_label, volume_value)\n        self.play(vol_group.animate.scale(0.8).to_edge(LEFT, buff=1.0).shift(DOWN*1.5))\n\n        # 5. SURFACE AREA (Infinite)\n        # Highlight the surface (top and bottom curves)\n        surface_label = Text(\"Surface Area\", font_size=40, color=RED).move_to(ORIGIN).to_edge(DOWN, buff=1.5)\n        surface_value = Text(\"S = \u221e\", font_size=60, color=RED).next_to(surface_label, DOWN)\n        \n        # Highlight curves red\n        self.play(\n            top_curve.animate.set_color(RED),\n            bottom_curve.animate.set_color(RED),\n            Write(surface_label)\n        )\n        self.wait(0.5)\n        self.play(Write(surface_value))\n        self.wait(2)\n        \n        # Move area text aside\n        area_group = VGroup(surface_label, surface_value)\n        self.play(area_group.animate.scale(0.8).to_edge(RIGHT, buff=1.0).shift(DOWN*1.5))\n\n        # 6. PARADOX\n        # Central text explanation\n        paradox_1 = Text(\"Can fill with finite paint...\", font_size=40, color=GREEN)\n        paradox_1.move_to(DOWN * 2.5)\n        \n        self.play(Write(paradox_1))\n        self.wait(2)\n        \n        paradox_2 = Text(\"But cannot paint the surface!\", font_size=40, color=RED)\n        paradox_2.move_to(DOWN * 2.5) # Same spot\n        \n        self.play(ReplacementTransform(paradox_1, paradox_2))\n        self.wait(2)\n\n        # 7. CONCLUSION\n        # Morph everything into final equation\n        final_text = Text(\"V = \u03c0   ,   S = \u221e\", font_size=72, color=YELLOW)\n        final_text.move_to(ORIGIN)\n        \n        # Gather all objects\n        all_objects = VGroup(\n            title,\n            axes_group, func_label, start_line, start_label, \n            top_curve, bottom_curve, horn_fill,\n            vol_group, area_group, paradox_2\n        )\n        \n        self.play(ReplacementTransform(all_objects, final_text), run_time=2)\n        self.wait(3)\n",
  "estimated_duration": 50
}