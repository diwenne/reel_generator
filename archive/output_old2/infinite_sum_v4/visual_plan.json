{
  "manim_code": "class InfiniteGeometricSum(Scene):\n    def construct(self):\n        # 1. SETUP TITLES AND MAIN CANVAS\n        # Use large font sizes for readability\n        title = Text(\"What is 1/2 + 1/4 + 1/8 + ...?\", font_size=52)\n        title.to_edge(UP, buff=0.2)\n        \n        # Initial equation at the bottom\n        equation = Text(\"Sum = 0\", font_size=48)\n        equation.to_edge(DOWN, buff=0.5)\n        \n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(Write(equation))\n\n        # 2. CREATE THE MAIN SQUARE\n        # Make it LARGE (side_length=6) to fill the screen effectively\n        full_square = Square(side_length=6, color=WHITE, stroke_width=3)\n        full_square.move_to(ORIGIN)\n        \n        # Visualize the total area first\n        label_1 = Text(\"1\", font_size=120, color=WHITE).set_opacity(0.3)\n        self.play(Create(full_square), FadeIn(label_1))\n        self.wait(1)\n        self.play(FadeOut(label_1))\n\n        # 3. ITERATIVE DIVISION LOGIC\n        # We will track the bounding box of the \"remaining\" area\n        # Start: x in [-3, 3], y in [-3, 3]\n        bounds = [-3.0, 3.0, -3.0, 3.0] # x_min, x_max, y_min, y_max\n        \n        colors = [BLUE, TEAL, GREEN, YELLOW, GOLD, RED, MAROON]\n        fractions = [\"1/2\", \"1/4\", \"1/8\", \"1/16\", \"1/32\", \"...\"]\n        equation_parts = [\"1/2\", \" + 1/4\", \" + 1/8\", \" + 1/16\", \" + ...\"]\n        \n        current_sum_text = \"Sum = \"\n        \n        # We will store rectangles to transform them later\n        rects = VGroup()\n        texts = VGroup()\n\n        # Loop through the first few terms\n        for i in range(5):\n            x_min, x_max, y_min, y_max = bounds\n            \n            # Determine geometry based on step (Vertical cut, then Horizontal cut)\n            if i % 2 == 0: # Even steps (0, 2, 4): Vertical Cut. Keep Right side for next.\n                width = (x_max - x_min) / 2\n                height = y_max - y_min\n                # The piece we take is the LEFT part of remaining\n                rect_x = x_min + width / 2\n                rect_y = (y_min + y_max) / 2\n                # Update bounds for next iteration (remaining is right side)\n                bounds[0] = x_min + width\n            else: # Odd steps (1, 3): Horizontal Cut. Keep Bottom side for next.\n                width = x_max - x_min\n                height = (y_max - y_min) / 2\n                # The piece we take is the TOP part of remaining\n                rect_x = (x_min + x_max) / 2\n                rect_y = y_max - height / 2\n                # Update bounds for next iteration (remaining is bottom side)\n                bounds[3] = y_max - height\n\n            # Create the rectangle shape\n            new_rect = Rectangle(width=width, height=height)\n            new_rect.move_to([rect_x, rect_y, 0])\n            new_rect.set_fill(colors[i], opacity=0.8)\n            new_rect.set_stroke(WHITE, width=2)\n            \n            # Create the label (only if not \"...\")\n            if i < 4:\n                label = Text(fractions[i], font_size=40 if i < 3 else 32)\n                label.move_to(new_rect.get_center())\n            else:\n                # Small dots for 1/32\n                label = Text(\"...\", font_size=24)\n                label.move_to(new_rect.get_center())\n\n            rects.add(new_rect)\n            texts.add(label)\n\n            # Update Equation Text\n            current_sum_text += equation_parts[i]\n            new_eq = Text(current_sum_text, font_size=48)\n            new_eq.to_edge(DOWN, buff=0.5)\n\n            # ANIMATION STEP\n            self.play(\n                FadeIn(new_rect, shift=0.2 * UR),\n                Write(label),\n                Transform(equation, new_eq),\n                run_time=1.0\n            )\n            self.wait(0.5)\n\n        # 4. FILL THE REST\n        # Quickly fill the tiny remaining corner to imply infinity\n        remaining_rect = Rectangle(\n            width=bounds[1]-bounds[0], \n            height=bounds[3]-bounds[2]\n        )\n        remaining_rect.move_to([\n            (bounds[0]+bounds[1])/2, \n            (bounds[2]+bounds[3])/2, \n            0\n        ])\n        remaining_rect.set_fill(GREY, opacity=0.5)\n        remaining_rect.set_stroke(WHITE, width=1)\n        \n        self.play(FadeIn(remaining_rect), run_time=0.5)\n        self.wait(1)\n\n        # 5. CONCLUSION\n        # Emphasize that the sum of parts equals the whole (1)\n        \n        # Flash the full square border\n        self.play(full_square.animate.set_stroke(YELLOW, width=8), run_time=0.5)\n        self.play(full_square.animate.set_stroke(WHITE, width=3), run_time=0.5)\n\n        # Transform equation to result\n        final_eq = Text(\"Sum = 1\", font_size=60, color=YELLOW)\n        final_eq.to_edge(DOWN, buff=0.5)\n        \n        # Group everything making up the square\n        all_parts = VGroup(rects, remaining_rect, texts)\n        \n        # Visual transformations\n        self.play(\n            FadeOut(title),\n            Transform(equation, final_eq),\n            all_parts.animate.set_opacity(1),\n            run_time=1.5\n        )\n        \n        # Final hold\n        self.wait(3)",
  "estimated_duration": 45
}