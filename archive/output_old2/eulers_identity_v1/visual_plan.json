{
  "manim_code": "def construct(self):\n    # 1. HOOK: Title and Question\n    title = Text(\"How are e, i, \u03c0, 1, 0 connected?\", font_size=48)\n    self.play(Write(title))\n    self.wait(2)\n    \n    # Move title to top\n    self.play(title.animate.scale(0.8).to_edge(UP, buff=0.3))\n    \n    # 2. SETUP: Complex Plane\n    # Visual radius for the unit circle\n    R = 2.5\n    \n    # Axes\n    x_axis = Line(LEFT * 5, RIGHT * 5, color=GREY)\n    y_axis = Line(DOWN * 3.5, UP * 3.5, color=GREY)\n    x_label = Text(\"Real\", font_size=24).next_to(x_axis, RIGHT, buff=0.1)\n    y_label = Text(\"Imaginary\", font_size=24).next_to(y_axis, UP, buff=0.1)\n    \n    # Markers for 1, -1, i, -i\n    # Mathematical 1 is at visual position R\n    marker_1 = Text(\"1\", font_size=32).move_to(RIGHT * (R + 0.3) + DOWN * 0.3)\n    marker_neg1 = Text(\"-1\", font_size=32).move_to(LEFT * (R + 0.3) + DOWN * 0.3)\n    marker_i = Text(\"i\", font_size=32).move_to(UP * (R + 0.3) + RIGHT * 0.3)\n    \n    plane_group = VGroup(x_axis, y_axis, x_label, y_label, marker_1, marker_neg1, marker_i)\n    \n    self.play(Create(x_axis), Create(y_axis))\n    self.play(Write(x_label), Write(y_label))\n    self.play(FadeIn(marker_1), FadeIn(marker_neg1), FadeIn(marker_i))\n    \n    # 3. VISUALIZING EULER'S FORMULA\n    # Draw Unit Circle\n    circle = Circle(radius=R, color=BLUE_E)\n    self.play(Create(circle), run_time=1.5)\n    \n    # Bottom Equation: e^(ix) = cos(x) + i sin(x)\n    # Constructing with superscripts manually for Text\n    eq_base = Text(\"e\", font_size=48)\n    eq_exp = Text(\"ix\", font_size=32).next_to(eq_base, UP + RIGHT, buff=0.05)\n    eq_rest = Text(\" = cos(x) + i sin(x)\", font_size=48).next_to(eq_base, RIGHT, buff=0.4, align_to_base=True)\n    # Adjust vertical alignment of the exponent part relative to base\n    eq_group = VGroup(eq_base, eq_exp, eq_rest).move_to(DOWN * 3.2)\n    \n    self.play(Write(eq_group))\n    self.wait(1.5)\n    \n    # 4. ANIMATION: Rotating Vector\n    # Initial vector at angle 0 (Right)\n    vector = Arrow(ORIGIN, RIGHT * R, buff=0, color=YELLOW)\n    dot = Dot(RIGHT * R, color=YELLOW)\n    \n    # Label for the moving point\n    point_label_base = Text(\"e\", font_size=36, color=YELLOW)\n    point_label_exp = Text(\"ix\", font_size=24, color=YELLOW).next_to(point_label_base, UP + RIGHT, buff=0.02)\n    point_label = VGroup(point_label_base, point_label_exp).next_to(dot, UP + RIGHT, buff=0.1)\n    \n    self.play(GrowArrow(vector), FadeIn(dot), Write(point_label))\n    \n    # Create an arc to show angle x\n    # We will animate rotation using a ValueTracker\n    angle_tracker = ValueTracker(0)\n    \n    # Update function for vector, dot, and label\n    def update_visuals(mob):\n        theta = angle_tracker.get_value()\n        # Update vector\n        new_vec = Arrow(ORIGIN, [R * np.cos(theta), R * np.sin(theta), 0], buff=0, color=YELLOW)\n        vector.become(new_vec)\n        # Update dot\n        dot.move_to(new_vec.get_end())\n        # Update label position\n        point_label.next_to(dot, UR, buff=0.1)\n\n    # Attach updater\n    vector.add_updater(lambda m: update_visuals(m))\n    # (Dot and label updated via the single updater on vector for simplicity in this logic, \n    # but better to add separate updaters or loop manually. Let's do manual loop for control)\n    vector.clear_updaters() # Reset to do it cleanly\n    \n    # 5. THE JOURNEY TO PI\n    # Change text to indicate x -> pi\n    sub_text = Text(\"Let angle x increase to \u03c0\", font_size=40, color=BLUE).next_to(title, DOWN)\n    self.play(Write(sub_text))\n    \n    # Animate rotation from 0 to PI\n    # Using always_redraw for smooth arc generation\n    arc = always_redraw(lambda: Arc(radius=0.5, start_angle=0, angle=angle_tracker.get_value(), color=RED))\n    self.add(arc)\n    \n    # Animate the value tracker\n    # We need to manually update dot/vector in an updater or just let ValueTracker drive them via add_updater\n    \n    vector.add_updater(lambda m: m.become(Arrow(ORIGIN, [R * np.cos(angle_tracker.get_value()), R * np.sin(angle_tracker.get_value()), 0], buff=0, color=YELLOW)))\n    dot.add_updater(lambda m: m.move_to([R * np.cos(angle_tracker.get_value()), R * np.sin(angle_tracker.get_value()), 0]))\n    point_label.add_updater(lambda m: m.next_to(dot, UR if angle_tracker.get_value() < PI/2 else UL, buff=0.1))\n    \n    self.play(angle_tracker.animate.set_value(PI), run_time=4, rate_func=smooth)\n    self.wait(1)\n    \n    # Remove updaters to freeze state\n    vector.clear_updaters()\n    dot.clear_updaters()\n    point_label.clear_updaters()\n    arc.clear_updaters()\n    \n    # 6. SUBSTITUTION\n    # Now we are at PI (180 degrees), which is position (-R, 0)\n    # Update Bottom Equation to: e^(i pi) = -1\n    \n    # Create the specific result equation\n    res_base = Text(\"e\", font_size=48)\n    res_exp = Text(\"i\u03c0\", font_size=32).next_to(res_base, UP + RIGHT, buff=0.05)\n    res_eq = Text(\" = -1\", font_size=48).next_to(res_base, RIGHT, buff=0.4, align_to_base=True)\n    res_group = VGroup(res_base, res_exp, res_eq).move_to(DOWN * 3.2)\n    \n    self.play(\n        FadeOut(eq_group),\n        FadeOut(sub_text),\n        Transform(point_label, VGroup(res_base.copy(), res_exp.copy()).move_to(point_label.get_center()))\n    )\n    self.play(Write(res_group))\n    self.wait(1)\n    \n    # Emphasize the -1 location\n    self.play(Indicate(marker_neg1, color=YELLOW, scale_factor=1.5))\n    self.wait(1)\n    \n    # 7. REARRANGEMENT\n    # e^(i pi) + 1 = 0\n    final_base = Text(\"e\", font_size=60)\n    final_exp = Text(\"i\u03c0\", font_size=40).next_to(final_base, UP + RIGHT, buff=0.05)\n    final_plus = Text(\" + 1 = 0\", font_size=60).next_to(final_base, RIGHT, buff=0.4, align_to_base=True)\n    final_eq_group = VGroup(final_base, final_exp, final_plus).move_to(DOWN * 3.2)\n    \n    self.play(TransformMatchingShapes(res_group, final_eq_group))\n    self.wait(2)\n    \n    # 8. FINAL MORPH\n    # Everything merges into the center equation\n    \n    # Create the grand final centered equation\n    grand_base = Text(\"e\", font_size=100, color=YELLOW)\n    grand_exp = Text(\"i\u03c0\", font_size=60, color=YELLOW).next_to(grand_base, UP + RIGHT, buff=0.1)\n    grand_rest = Text(\" + 1 = 0\", font_size=100, color=YELLOW).next_to(grand_base, RIGHT, buff=0.5, align_to_base=True)\n    grand_final = VGroup(grand_base, grand_exp, grand_rest).move_to(ORIGIN)\n    \n    # Group all existing items\n    all_screen_items = VGroup(\n        title, plane_group, circle, vector, dot, point_label, arc, final_eq_group\n    )\n    \n    self.play(\n        ReplacementTransform(all_screen_items, grand_final),\n        run_time=2.5\n    )\n    \n    self.wait(3)",
  "estimated_duration": 45
}