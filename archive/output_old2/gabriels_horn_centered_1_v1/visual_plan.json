{
  "manim_code": "import numpy as np\nfrom manim import *\n\nclass GabrielsHorn(Scene):\n    def construct(self):\n        # 1. Hook: Title\n        # Start at CENTER (ORIGIN) as requested, then move up\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        title.move_to(ORIGIN)\n        self.play(Write(title))\n        self.wait(1.5)\n        \n        # Move title to top edge to clear the stage\n        self.play(title.animate.scale(0.8).to_edge(UP, buff=0.3))\n        self.wait(0.5)\n\n        # 2. The Function: y = 1/x\n        # Build manual fraction using simple shapes (NO LaTeX)\n        y_label = Text(\"y =\", font_size=72)\n        one = Text(\"1\", font_size=60)\n        line = Line(LEFT, RIGHT).scale(0.6).set_stroke(width=6)\n        x_var = Text(\"x\", font_size=60)\n        \n        # Position fraction parts vertically\n        one.next_to(line, UP, buff=0.15)\n        x_var.next_to(line, DOWN, buff=0.15)\n        fraction = VGroup(one, line, x_var)\n        \n        # Combine into equation and CENTER it\n        fraction.next_to(y_label, RIGHT, buff=0.4)\n        equation = VGroup(y_label, fraction).move_to(ORIGIN)\n        \n        self.play(Write(equation))\n        self.wait(2.5)\n\n        # 3. Transition to Graph\n        self.play(FadeOut(equation))\n        \n        # Define graph parameters\n        # Shift origin left so the horn (x=1 to x=7) is centered visually\n        origin = LEFT * 5 + DOWN * 1.5\n        x_scale = 1.3\n        y_scale = 1.3\n        \n        # Axes\n        x_axis = Arrow(start=origin, end=origin + RIGHT * 9, buff=0, color=GREY)\n        y_axis = Arrow(start=origin + DOWN * 1, end=origin + UP * 3.5, buff=0, color=GREY)\n        x_text = Text(\"x\", font_size=32).next_to(x_axis, DOWN)\n        y_text = Text(\"y\", font_size=32).next_to(y_axis, LEFT)\n        \n        axes_group = VGroup(x_axis, y_axis, x_text, y_text)\n        self.play(Create(axes_group))\n        \n        # Draw curve 1/x from x=1 to x=6.5\n        # We calculate points manually to avoid Latex/Plot issues\n        def get_curve_points(start_x, end_x, invert=False):\n            points = []\n            steps = 60\n            for i in range(steps + 1):\n                x_val = start_x + (end_x - start_x) * (i / steps)\n                y_val = 1.0 / x_val\n                if invert: y_val = -y_val\n                # Map to screen coordinates\n                pt = origin + RIGHT * (x_val * x_scale) + UP * (y_val * y_scale)\n                points.append(pt)\n            return points\n\n        top_points = get_curve_points(1, 6.5)\n        top_curve = VMobject().set_points_smoothly(top_points).set_color(BLUE).set_stroke(width=5)\n        \n        # Indicator for x=1 start point\n        start_pt = origin + RIGHT * (1 * x_scale)\n        top_start = start_pt + UP * (1 * y_scale)\n        dashed_line = DashedLine(start_pt, top_start, color=GREY)\n        label_1 = Text(\"x=1\", font_size=32).next_to(start_pt, DOWN, buff=0.2)\n        \n        self.play(Create(dashed_line), Write(label_1))\n        self.play(Create(top_curve), run_time=2.5)\n        self.wait(1)\n\n        # 4. The Horn (Visualizing rotation)\n        # Create bottom reflection curve\n        bottom_points = get_curve_points(1, 6.5, invert=True)\n        bottom_curve = VMobject().set_points_smoothly(bottom_points).set_color(BLUE).set_stroke(width=5)\n        \n        # Create ellipses to simulate 3D volume (The \"Disks\")\n        def get_ellipse(x_val):\n            radius = (1.0 / x_val) * y_scale\n            center = origin + RIGHT * (x_val * x_scale)\n            # Fixed small width for perspective, height is 2*radius\n            return Ellipse(width=0.4, height=2*radius, color=BLUE_E, stroke_width=2).move_to(center)\n\n        disks = VGroup()\n        for x_pos in [1, 2, 3, 4.5, 6.5]:\n            disks.add(get_ellipse(x_pos))\n        \n        # Fill the horn body (polygon between curves)\n        fill_points = top_points + bottom_points[::-1]\n        horn_fill = Polygon(*fill_points, color=BLUE, stroke_width=0, fill_opacity=0.3)\n\n        self.play(\n            Create(bottom_curve),\n            FadeIn(horn_fill),\n            run_time=2\n        )\n        self.play(Create(disks), run_time=2)\n        self.wait(1.5)\n\n        # 5. Finite Volume\n        # Text centered ABOVE the horn in the clear space\n        vol_label = Text(\"Volume = \u03c0\", font_size=56, color=GREEN)\n        vol_label.move_to(UP * 2.2) \n        \n        self.play(Write(vol_label))\n        self.wait(2.5)\n\n        # 6. Infinite Surface Area\n        # Positioned below volume but above horn\n        area_label = Text(\"Surface Area = \u221e\", font_size=56, color=RED)\n        area_label.next_to(vol_label, DOWN, buff=0.5)\n        \n        self.play(Write(area_label))\n        self.wait(3)\n\n        # 7. Explanation Statement\n        # Replace the math labels with the key intuition\n        explanation = Text(\"Finite volume does not imply\\nfinite surface area.\", font_size=42, line_spacing=1.2)\n        explanation.move_to(UP * 1.8)\n        \n        self.play(\n            FadeOut(vol_label),\n            FadeOut(area_label),\n            Write(explanation)\n        )\n        self.wait(4)\n\n        # 8. Final Conclusion\n        # Morph everything into final summary screen\n        final_title = Text(\"Gabriel's Horn\", font_size=64, color=BLUE)\n        final_title.move_to(UP * 0.8)\n        \n        final_stats = Text(\"V = \u03c0   ,   S = \u221e\", font_size=72, color=YELLOW)\n        final_stats.next_to(final_title, DOWN, buff=0.6)\n        \n        final_group = VGroup(final_title, final_stats).move_to(ORIGIN)\n        \n        # Gather all visible objects to transform\n        all_objects = VGroup(\n            title, explanation, \n            top_curve, bottom_curve, horn_fill, disks, \n            axes_group, dashed_line, label_1\n        )\n        \n        self.play(ReplacementTransform(all_objects, final_group), run_time=2)\n        self.wait(5)",
  "estimated_duration": 55
}