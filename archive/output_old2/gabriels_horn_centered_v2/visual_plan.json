{
  "manim_code": "class GabrielsHorn(Scene):\n    def construct(self):\n        # 1. Title Hook\n        title = Text(\"Infinite Surface Finite Volume?\", font_size=56)\n        title.move_to(ORIGIN)\n        self.play(Write(title))\n        self.wait(1.5)\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n\n        # 2. Define Equation y = 1/x manually (NO LATEX)\n        y_text = Text(\"y =\", font_size=48)\n        num = Text(\"1\", font_size=48)\n        div_line = Line(start=LEFT*0.3, end=RIGHT*0.3, stroke_width=4)\n        den = Text(\"x\", font_size=48)\n        \n        # Group fraction parts vertically\n        fraction = VGroup(num, div_line, den).arrange(DOWN, buff=0.1)\n        \n        # Group whole equation horizontally\n        equation = VGroup(y_text, fraction).arrange(RIGHT, buff=0.2).move_to(ORIGIN)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation to top left to make room\n        self.play(equation.animate.scale(0.7).to_edge(LEFT, buff=1).shift(UP*2))\n\n        # 3. Draw Graph axes and Curve\n        # We simulate axes with lines to avoid Axes() object complexity if not needed, \n        # but Axes are standard. However, simple lines give us absolute control.\n        axis_x = Arrow(start=LEFT*4, end=RIGHT*4, color=GRAY)\n        axis_y = Arrow(start=DOWN*2.5, end=UP*2.5, color=GRAY).move_to(LEFT*3)\n        \n        # Shift x axis to align with y axis origin\n        axis_x.move_to(LEFT*3 + RIGHT*4) # Center of arrow is at (1,0)\n        # Correct logic: Origin is at (-3, 0)\n        origin_point = np.array([-3, 0, 0])\n        axis_x.put_start_and_end_on(origin_point + LEFT, origin_point + RIGHT*8)\n        axis_y.put_start_and_end_on(origin_point + DOWN*2, origin_point + UP*2.5)\n        \n        axes_group = VGroup(axis_x, axis_y)\n        \n        self.play(Create(axes_group))\n        \n        # Draw 1/x curve\n        # Map x=1..infinity to screen coordinates relative to origin_point\n        # x starts at 1 (screen -3) and goes right.\n        # y = 1/x. Scale factor needed for visibility.\n        scale_x = 1.0\n        scale_y = 2.0\n        \n        # Generate points for top curve\n        points_top = []\n        points_bottom = []\n        x_values = np.linspace(1, 7, 100)\n        \n        for x_val in x_values:\n            screen_x = origin_point[0] + (x_val - 1) * scale_x\n            screen_y_top = origin_point[1] + (1/x_val) * scale_y\n            screen_y_bot = origin_point[1] - (1/x_val) * scale_y\n            points_top.append([screen_x, screen_y_top, 0])\n            points_bottom.append([screen_x, screen_y_bot, 0])\n            \n        curve_top = VMobject(color=BLUE, stroke_width=4).set_points_smoothly(points_top)\n        curve_bottom = VMobject(color=BLUE, stroke_width=4).set_points_smoothly(points_bottom)\n        \n        self.play(Create(curve_top))\n        self.wait(0.5)\n        \n        # 4. Construct the Horn (Pseudo-3D)\n        # Show rotation indicator\n        rotation_arrow = Arc(radius=0.5, start_angle=PI/4, angle=3*PI/2, arc_center=origin_point, color=YELLOW)\n        rotation_arrow.add_tip()\n        rotate_text = Text(\"Rotate\", font_size=32, color=YELLOW).next_to(rotation_arrow, UP, buff=0.1)\n        \n        self.play(Create(rotation_arrow), Write(rotate_text))\n        self.play(Create(curve_bottom), FadeOut(equation))\n        self.play(FadeOut(rotation_arrow), FadeOut(rotate_text))\n        \n        # Draw ellipses to show 3D volume\n        ellipses = VGroup()\n        for i in [0, 10, 30, 60, 99]: # Indices from x_values\n            p_top = points_top[i]\n            p_bot = points_bottom[i]\n            height = p_top[1] - p_bot[1]\n            center = (np.array(p_top) + np.array(p_bot)) / 2\n            # Width is small to look like a circle viewed from side\n            el = Ellipse(width=0.4, height=height, color=BLUE_A, stroke_width=2)\n            el.move_to(center)\n            ellipses.add(el)\n            \n        self.play(Create(ellipses))\n        self.wait(1)\n\n        # 5. Volume Calculation\n        # Text: V = \u222b \u03c0(1/x)\u00b2 dx = \u03c0\n        # Create complex equation with text parts\n        vol_text_1 = Text(\"Volume =\", font_size=40, color=GREEN)\n        vol_int = Text(\"\u222b\", font_size=40, color=GREEN)\n        vol_pi = Text(\"\u03c0\", font_size=40, color=GREEN)\n        \n        # (1/x)^2\n        v_num = Text(\"1\", font_size=30, color=GREEN)\n        v_line = Line(LEFT*0.2, RIGHT*0.2, color=GREEN)\n        v_den = Text(\"x\u00b2\", font_size=30, color=GREEN)\n        v_frac = VGroup(v_num, v_line, v_den).arrange(DOWN, buff=0.05)\n        \n        vol_dx = Text(\"dx = \u03c0\", font_size=40, color=GREEN)\n        \n        # Arrange full volume equation\n        vol_eq = VGroup(vol_text_1, vol_int, vol_pi, v_frac, vol_dx).arrange(RIGHT, buff=0.15)\n        vol_eq.move_to(DOWN * 2.5)\n        \n        self.play(Write(vol_eq))\n        self.wait(2)\n        \n        # 6. Surface Calculation\n        # Text: Area = \u222b 2\u03c0(1/x) dx = \u221e\n        surf_text_1 = Text(\"Surface =\", font_size=40, color=RED)\n        surf_int = Text(\"\u222b\", font_size=40, color=RED)\n        surf_2pi = Text(\"2\u03c0\", font_size=40, color=RED)\n        \n        # 1/x\n        s_num = Text(\"1\", font_size=30, color=RED)\n        s_line = Line(LEFT*0.2, RIGHT*0.2, color=RED)\n        s_den = Text(\"x\", font_size=30, color=RED)\n        s_frac = VGroup(s_num, s_line, s_den).arrange(DOWN, buff=0.05)\n        \n        surf_dx = Text(\"dx = \u221e\", font_size=40, color=RED)\n        \n        # Arrange full surface equation\n        surf_eq = VGroup(surf_text_1, surf_int, surf_2pi, s_frac, surf_dx).arrange(RIGHT, buff=0.15)\n        surf_eq.next_to(vol_eq, DOWN, buff=0.3)\n        \n        self.play(Write(surf_eq))\n        self.wait(2)\n\n        # 7. Paradox Text\n        # Clear bottom equations to make space for big text\n        self.play(FadeOut(vol_eq), FadeOut(surf_eq))\n        \n        fill_text = Text(\"Fill inside? YES\", font_size=48, color=GREEN)\n        paint_text = Text(\"Paint surface? NO\", font_size=48, color=RED)\n        \n        paradox_group = VGroup(fill_text, paint_text).arrange(DOWN, buff=0.5)\n        paradox_group.move_to(DOWN * 2.5)\n        \n        self.play(Write(paradox_group))\n        self.wait(2)\n        \n        # 8. Conclusion\n        # Final morph into single summarized view\n        final_title = Text(\"Gabriel's Horn\", font_size=64, color=BLUE)\n        final_stats = Text(\"V = \u03c0     S = \u221e\", font_size=56, color=YELLOW)\n        final_group = VGroup(final_title, final_stats).arrange(DOWN, buff=0.6).move_to(ORIGIN)\n        \n        # Gather everything to morph\n        all_visible = VGroup(title, axes_group, curve_top, curve_bottom, ellipses, paradox_group)\n        \n        self.play(ReplacementTransform(all_visible, final_group), run_time=1.5)\n        self.wait(3)",
  "estimated_duration": 50
}