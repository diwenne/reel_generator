{
  "manim_code": "from manim import *\n\nclass InfiniteSum(Scene):\n    def construct(self):\n        # 1. HOOK\n        # Initial question centered\n        title = Text(\"What is 1/2 + 1/4 + 1/8 + ...?\", font_size=48)\n        self.play(Write(title))\n        self.wait(1.5)\n        \n        # Move title to top safe zone\n        self.play(title.animate.scale(0.8).to_edge(UP, buff=0.3))\n        \n        # 2. SETUP\n        # Define the main square geometry\n        # Center is slightly shifted up to balance between title and bottom text\n        center_point = UP * 0.3\n        square_side = 5.0\n        \n        # The main container square (represents 1)\n        main_square = Square(side_length=square_side, color=WHITE, stroke_width=4)\n        main_square.move_to(center_point)\n        \n        label_one = Text(\"1\", font_size=60)\n        label_one.move_to(center_point)\n        \n        self.play(Create(main_square), Write(label_one))\n        self.wait(1)\n        self.play(FadeOut(label_one))\n        \n        # Bottom sum text placeholder\n        sum_label = Text(\"Sum = 0\", font_size=40)\n        sum_label.to_edge(DOWN, buff=0.5)\n        self.play(Write(sum_label))\n        \n        # 3. BUILD THE SERIES\n        # We will dynamically slice the square\n        # Coordinates relative to center\n        # Start with full bounds: x in [-2.5, 2.5], y in [-2.5, 2.5]\n        \n        bounds = [\n            -square_side/2,  # x_min\n             square_side/2,  # x_max\n            -square_side/2,  # y_min\n             square_side/2   # y_max\n        ]\n        \n        # Sequence data: (fraction_text, color, accum_text)\n        steps = [\n            (\"1/2\", BLUE, \"Sum = 1/2\"),\n            (\"1/4\", TEAL, \"Sum = 3/4\"),\n            (\"1/8\", GREEN, \"Sum = 7/8\"),\n            (\"1/16\", YELLOW, \"Sum = 15/16\"),\n            (\"1/32\", ORANGE, \"Sum = 31/32\"),\n            (\"1/64\", RED, \"Sum \u2248 1\")\n        ]\n        \n        rects = []\n        labels = []\n        \n        for i, (frac_text, col, sum_text) in enumerate(steps):\n            # Calculate current rectangle dimensions based on bounds\n            curr_x_min, curr_x_max, curr_y_min, curr_y_max = bounds\n            \n            width = curr_x_max - curr_x_min\n            height = curr_y_max - curr_y_min\n            \n            # Determine cut direction and new bounds\n            # Even i (0, 2, 4...): Vertical Cut (Left part kept)\n            # Odd i (1, 3, 5...): Horizontal Cut (Top part kept)\n            \n            if i % 2 == 0:\n                # Vertical cut, keep left half\n                rect_width = width / 2\n                rect_height = height\n                # Center of new rect\n                new_center = np.array([\n                    curr_x_min + rect_width/2,\n                    curr_y_min + rect_height/2,\n                    0\n                ])\n                # Update bounds for NEXT iteration (the remaining right half)\n                bounds[0] = curr_x_min + rect_width\n            else:\n                # Horizontal cut, keep top half\n                rect_width = width\n                rect_height = height / 2\n                # Center of new rect\n                new_center = np.array([\n                    curr_x_min + rect_width/2,\n                    curr_y_max - rect_height/2,\n                    0\n                ])\n                # Update bounds for NEXT iteration (the remaining bottom half)\n                bounds[3] = curr_y_max - rect_height\n            \n            # Adjust center relative to main_square position\n            abs_center = center_point + new_center\n            \n            # Create the shape\n            rect = Rectangle(width=rect_width, height=rect_height)\n            rect.set_fill(col, opacity=0.8)\n            rect.set_stroke(WHITE, width=2)\n            rect.move_to(abs_center)\n            \n            # Create label (only for first few visible ones)\n            if i < 4:\n                lbl = Text(frac_text, font_size=48 - (i*6))\n                lbl.move_to(abs_center)\n            else:\n                lbl = VGroup() # Empty for small shapes\n            \n            # ANIMATION\n            self.play(DrawBorderThenFill(rect), run_time=0.8)\n            if i < 4:\n                self.play(Write(lbl), run_time=0.5)\n            \n            # Update Sum equation\n            new_sum_label = Text(sum_text, font_size=40).to_edge(DOWN, buff=0.5)\n            self.play(Transform(sum_label, new_sum_label), run_time=0.8)\n            \n            rects.append(rect)\n            labels.append(lbl)\n            self.wait(0.5)\n        \n        # 4. REVEAL / INTUITION\n        # Highlight the tiny remaining space\n        remaining_box = Rectangle(\n            width=bounds[1]-bounds[0], \n            height=bounds[3]-bounds[2],\n            color=PURE_RED, \n            stroke_width=4\n        )\n        remaining_box.move_to(center_point + np.array([\n            (bounds[0]+bounds[1])/2,\n            (bounds[2]+bounds[3])/2,\n            0\n        ]))\n        \n        # Flash the empty space to emphasize it gets smaller\n        self.play(Create(remaining_box))\n        self.play(remaining_box.animate.set_fill(WHITE, opacity=1), rate_func=there_and_back, run_time=1)\n        self.play(FadeOut(remaining_box))\n        self.wait(1)\n\n        # 5. DRAMATIC FINALE\n        # Clear everything\n        all_objects = rects + labels + [main_square, sum_label, title]\n        self.play(*[FadeOut(obj) for obj in all_objects], run_time=1.0)\n        \n        # Final Equation centered\n        final_text = Text(\"1/2 + 1/4 + 1/8 + ... = 1\", font_size=72, color=YELLOW)\n        final_text.move_to(ORIGIN)\n        \n        self.play(Write(final_text), run_time=2.0)\n        self.wait(3)",
  "estimated_duration": 34
}