{
  "manim_code": "def construct(self):\n    # 1. HOOK: Title starts centered, then moves UP\n    title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n    self.play(Write(title))\n    self.wait(1.5)\n    \n    # Move title to top to clear the stage\n    title_target = Text(\"Gabriel's Horn Paradox\", font_size=48, color=BLUE)\n    title_target.to_edge(UP, buff=0.2)\n    self.play(Transform(title, title_target))\n    self.wait(1)\n\n    # 2. DEFINE THE FUNCTION: y = 1/x\n    # Create \"y = \"\n    y_label = Text(\"y =\", font_size=48)\n    \n    # Create fraction \"1/x\" using VGroup for proper vertical alignment\n    numer = Text(\"1\", font_size=48)\n    div_line = Line(LEFT*0.3, RIGHT*0.3, color=WHITE).set_stroke(width=4)\n    denom = Text(\"x\", font_size=48)\n    fraction = VGroup(numer, div_line, denom).arrange(DOWN, buff=0.1)\n    \n    # Group equation parts\n    equation = VGroup(y_label, fraction).arrange(RIGHT, buff=0.3)\n    equation.move_to(UP * 2.5 + LEFT * 3) # Place in top-left area\n    \n    domain_txt = Text(\"for x \u2265 1\", font_size=40, color=GRAY)\n    domain_txt.next_to(equation, RIGHT, buff=0.5)\n    \n    self.play(Write(equation))\n    self.play(Write(domain_txt))\n    self.wait(1)\n\n    # 3. DRAW THE GRAPH & BUILD THE HORN (2D Projection)\n    # We simulate the horn using 2D curves and ellipses to avoid 3D camera issues\n    # Origin roughly at left side, extending right\n    origin = LEFT * 4 + DOWN * 1.5\n    x_axis_len = 9\n    \n    # Draw Axis line\n    axis = Line(origin, origin + RIGHT * x_axis_len, color=GRAY)\n    x_label = Text(\"x\", font_size=36).next_to(axis, RIGHT)\n    self.play(Create(axis), Write(x_label))\n    \n    # Define points for the curves\n    # We plot y = 1.5 / x relative to our scene scale to make it look good\n    # Starting at visual x=0 (which represents mathematical x=1)\n    \n    # Upper curve points\n    points_up = []\n    points_down = []\n    steps = 40\n    scale_factor = 2.0 # Height scale\n    x_scale = 1.2      # Width scale\n    \n    for i in range(steps + 1):\n        u = i / steps # 0 to 1\n        # Map u to mathematical x: 1 to 10\n        math_x = 1 + u * 9 \n        \n        # Visual coordinates\n        vis_x = (math_x - 1) * x_scale\n        vis_y = scale_factor / math_x\n        \n        pt_up = origin + RIGHT * vis_x + UP * vis_y\n        pt_down = origin + RIGHT * vis_x + DOWN * vis_y\n        \n        points_up.append(pt_up)\n        points_down.append(pt_down)\n        \n    # Create the curves\n    curve_up = VMobject().set_points_smoothly(points_up).set_color(WHITE)\n    curve_down = VMobject().set_points_smoothly(points_down).set_color(WHITE)\n    \n    # Opening Ellipse (at x=1)\n    # Height is scale_factor/1 = 2.0. Radius = 2.0\n    opening = Ellipse(width=0.8, height=2 * scale_factor, color=WHITE)\n    opening.move_to(origin + UP*0 + RIGHT*0)\n    \n    self.play(Create(curve_up))\n    self.wait(0.5)\n    \n    # Animate rotation effect to form the horn\n    # Show bottom curve and the opening ellipse\n    self.play(\n        Create(curve_down),\n        Create(opening),\n        run_time=2\n    )\n    \n    # Add a few cross-section ellipses to emphasize 3D shape\n    ellipses = VGroup()\n    for i in [10, 25]: # Indices from our points list\n        p_top = points_up[i]\n        p_bot = points_down[i]\n        center = (p_top + p_bot) / 2\n        height = p_top[1] - p_bot[1]\n        e = Ellipse(width=0.3, height=height, color=GRAY, stroke_opacity=0.5)\n        e.move_to(center)\n        ellipses.add(e)\n        \n    self.play(FadeIn(ellipses))\n    \n    horn_group = VGroup(axis, x_label, curve_up, curve_down, opening, ellipses)\n    self.wait(1)\n\n    # 4. VOLUME CALCULATION (Green)\n    # Formula: Integral of Area = pi * r^2\n    vol_label = Text(\"Volume\", font_size=44, color=GREEN)\n    vol_label.move_to(UP * 0.5 + RIGHT * 2)\n    \n    # Show disk area formula\n    # Area = pi * (1/x)^2\n    area_text_1 = Text(\"Area = \u03c0 \u00b7 radius\u00b2\", font_size=36, color=GREEN)\n    area_text_2 = Text(\"Sum \u2192 Finite\", font_size=44, color=GREEN)\n    \n    vol_group = VGroup(vol_label, area_text_1, area_text_2).arrange(DOWN, buff=0.2)\n    vol_group.next_to(horn_group, UP, buff=0.5).shift(RIGHT*1)\n    \n    self.play(Write(vol_label))\n    self.play(FadeIn(area_text_1))\n    self.wait(1)\n    \n    # Highlight a slice\n    slice_idx = 8\n    slice_h = points_up[slice_idx][1] - points_down[slice_idx][1]\n    slice_disk = Ellipse(width=0.4, height=slice_h, color=GREEN, fill_opacity=0.5)\n    slice_disk.move_to((points_up[slice_idx] + points_down[slice_idx])/2)\n    \n    self.play(FadeIn(slice_disk))\n    self.play(Transform(area_text_1, area_text_2))\n    \n    # Final Volume Result\n    vol_final = Text(\"Volume = \u03c0\", font_size=52, color=GREEN)\n    vol_final.move_to(vol_group.get_center())\n    self.play(ReplacementTransform(VGroup(vol_label, area_text_1, area_text_2), vol_final))\n    self.wait(1)\n\n    # 5. SURFACE AREA CALCULATION (Red)\n    # Formula: Integral of Circumference = 2 * pi * r\n    surf_label = Text(\"Surface Area\", font_size=44, color=RED)\n    surf_label.move_to(vol_final.get_center() + DOWN * 1.5)\n    \n    # Circumference = 2 * pi * (1/x)\n    circ_text_1 = Text(\"Circum. = 2\u03c0 \u00b7 radius\", font_size=36, color=RED)\n    circ_text_2 = Text(\"Sum \u2192 Infinite\", font_size=44, color=RED)\n    \n    surf_group = VGroup(surf_label, circ_text_1, circ_text_2).arrange(DOWN, buff=0.2)\n    surf_group.move_to(vol_final.get_center() + DOWN * 2.0)\n    \n    self.play(Write(surf_label))\n    self.play(FadeIn(circ_text_1))\n    self.wait(1)\n    \n    # Highlight the ring (edge of the slice)\n    slice_ring = slice_disk.copy().set_fill(opacity=0).set_stroke(color=RED, width=6)\n    \n    self.play(Create(slice_ring))\n    self.play(Transform(circ_text_1, circ_text_2))\n    \n    # Final Surface Result\n    surf_final = Text(\"Surface = \u221e\", font_size=52, color=RED)\n    surf_final.move_to(surf_group.get_center())\n    self.play(ReplacementTransform(VGroup(surf_label, circ_text_1, circ_text_2), surf_final))\n    self.wait(2)\n\n    # 6. THE PARADOX ANALOGY\n    # Clear some space or use bottom area\n    \n    paradox_1 = Text(\"Fill with paint? YES (\u03c0)\", font_size=40, color=GREEN)\n    paradox_2 = Text(\"Paint the surface? NO (\u221e)\", font_size=40, color=RED)\n    \n    paradox_group = VGroup(paradox_1, paradox_2).arrange(DOWN, buff=0.3)\n    paradox_group.to_edge(DOWN, buff=0.5)\n    \n    self.play(Write(paradox_1))\n    self.wait(1)\n    self.play(Write(paradox_2))\n    self.wait(2)\n\n    # 7. CONCLUSION: MORPH EVERYTHING TO FINAL SUMMARY\n    # Final State: \"V = \u03c0, S = \u221e\"\n    \n    final_summary = Text(\"V = \u03c0   ,   S = \u221e\", font_size=72, color=YELLOW)\n    final_summary.move_to(ORIGIN)\n    \n    # Gather all objects\n    # title is at top, equation at top left\n    # horn_group is main visual\n    # vol_final and surf_final are calculations\n    # paradox_group is bottom text\n    # slice_disk and slice_ring are temp highlights\n    \n    all_objects = VGroup(\n        title, equation, domain_txt,\n        horn_group, slice_disk, slice_ring,\n        vol_final, surf_final,\n        paradox_group\n    )\n    \n    self.play(\n        ReplacementTransform(all_objects, final_summary),\n        run_time=2\n    )\n    \n    self.wait(3)",
  "estimated_duration": 55
}