{
  "manim_code": "from manim import *\n\nclass InfiniteSumProof(Scene):\n    def construct(self):\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # 1. SETUP & TITLE\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        title = Text(\"Why does 1/2 + 1/4 + ... = 1?\", font_size=56)\n        title.to_edge(UP, buff=0.4)\n        self.play(Write(title), run_time=2)\n        self.wait(1.5)\n\n        # Shrink title to corner to open the stage for the visual\n        title_corner = title.copy().scale(0.6).to_corner(UL, buff=0.3)\n        self.play(Transform(title, title_corner))\n        self.wait(0.5)\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # 2. THE UNIT SQUARE\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # Define geometry variables\n        # We shift slightly down to ensure gap from title and room for bottom text\n        square_size = 5.0\n        center_pos = DOWN * 0.2\n        \n        # Create main container (The \"1\")\n        full_square = Square(side_length=square_size, color=WHITE)\n        full_square.move_to(center_pos)\n        \n        # Label to establish the value 1\n        area_label = Text(\"Total Area = 1\", font_size=48)\n        area_label.move_to(full_square.get_center())\n        \n        self.play(Create(full_square), Write(area_label))\n        self.wait(2)\n        \n        # Clear label for the process\n        self.play(FadeOut(area_label))\n        \n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # 3. THE GEOMETRIC SERIES ANIMATION\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        \n        # Variables to track the \"hole\" (remaining area)\n        l = full_square.get_left()[0]\n        r = full_square.get_right()[0]\n        t = full_square.get_top()[1]\n        b = full_square.get_bottom()[1]\n        \n        # Bottom equation tracker\n        sum_text = Text(\"Sum: 0\", font_size=48).to_edge(DOWN, buff=0.4)\n        self.play(Write(sum_text))\n        \n        # Groups for final transform\n        rects_group = VGroup()\n        labels_group = VGroup()\n        \n        current_sum = 0.0\n        \n        # Patterns for the spiral: Direction, Color\n        # We cycle through Left -> Top -> Right -> Bottom\n        directions = [\"Left\", \"Top\", \"Right\", \"Bottom\"]\n        colors = [BLUE, GREEN, RED, ORANGE, PURPLE, TEAL, MAROON, GOLD]\n        \n        # Logic: First 4 steps get labels, subsequent steps are fast filler\n        labeled_steps = 4  # 1/2, 1/4, 1/8, 1/16\n        total_steps = 9    # Continue smaller to show convergence\n        \n        for i in range(total_steps):\n            fraction = 1.0 / (2**(i+1))\n            direction = directions[i % 4]\n            color = colors[i % len(colors)]\n            \n            # Calculate geometry of the new slice based on remaining bounds\n            width = r - l\n            height = t - b\n            new_rect = None\n            \n            if direction == \"Left\":\n                new_w = width / 2\n                new_rect = Rectangle(width=new_w, height=height)\n                new_rect.move_to(np.array([l + new_w/2, (t+b)/2, 0]))\n                l += new_w\n            elif direction == \"Top\":\n                new_h = height / 2\n                new_rect = Rectangle(width=width, height=new_h)\n                new_rect.move_to(np.array([(l+r)/2, t - new_h/2, 0]))\n                t -= new_h\n            elif direction == \"Right\":\n                new_w = width / 2\n                new_rect = Rectangle(width=new_w, height=height)\n                new_rect.move_to(np.array([r - new_w/2, (t+b)/2, 0]))\n                r -= new_w\n            elif direction == \"Bottom\":\n                new_h = height / 2\n                new_rect = Rectangle(width=width, height=new_h)\n                new_rect.move_to(np.array([(l+r)/2, b + new_h/2, 0]))\n                b += new_h\n                \n            # Formatting\n            new_rect.set_fill(color, opacity=0.8)\n            new_rect.set_stroke(WHITE, width=2)\n            \n            # Dynamic pacing: Start slow, then accelerate\n            step_time = max(0.2, 1.5 - i * 0.15) \n            \n            self.play(FadeIn(new_rect), run_time=step_time)\n            rects_group.add(new_rect)\n            \n            # Labels (only for the first few larger blocks to avoid clutter)\n            if i < labeled_steps:\n                label_val = f\"1/{2**(i+1)}\"\n                lbl = Text(label_val, font_size=44)\n                if i == 3: lbl.scale(0.8) # Fit 1/16 nicely\n                lbl.move_to(new_rect.get_center())\n                self.play(Write(lbl), run_time=0.5)\n                labels_group.add(lbl)\n                self.wait(1.0) # Let the viewer absorb the visual\n            else:\n                self.wait(0.1) # Fast visual filling for the rest\n            \n            # Update Sum Text\n            current_sum += fraction\n            \n            # Switch from showing decimals to showing concept\n            if i < 4:\n                new_txt_str = f\"Sum: {current_sum:g}\"\n            else:\n                new_txt_str = \"Sum \u2192 1\"\n                \n            new_sum_text = Text(new_txt_str, font_size=48).to_edge(DOWN, buff=0.4)\n            # Replace old text with new text (avoid overlap)\n            self.play(Transform(sum_text, new_sum_text), run_time=0.5)\n\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        # 4. CONCLUSION\n        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n        \n        # Highlight the infinitesimal gap being filled\n        remaining_gap = Rectangle(width=r-l, height=t-b, color=YELLOW)\n        remaining_gap.move_to(np.array([(l+r)/2, (t+b)/2, 0]))\n        remaining_gap.set_fill(YELLOW, opacity=1)\n        \n        self.play(FadeIn(remaining_gap))\n        rects_group.add(remaining_gap)\n        \n        # Update text one last time to the result\n        final_sum_str = Text(\"Sum = 1\", font_size=48, color=YELLOW).to_edge(DOWN, buff=0.4)\n        self.play(Transform(sum_text, final_sum_str))\n        self.wait(2)\n        \n        # Final Morph: Transform EVERYTHING into the single equation\n        final_equation = Text(\"1/2 + 1/4 + ... = 1\", font_size=72, color=YELLOW).move_to(ORIGIN)\n        \n        # Gather all visible objects\n        all_objects = VGroup(title, full_square, rects_group, labels_group, sum_text)\n        \n        self.play(\n            ReplacementTransform(all_objects, final_equation),\n            run_time=2.5\n        )\n        \n        self.wait(3)",
  "estimated_duration": 65
}