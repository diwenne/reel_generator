{
  "manim_code": "import random\n\nclass MonteCarloPi(Scene):\n    def construct(self):\n        # 1. SETUP TITLE\n        # Start at center\n        title = Text(\"Throwing Darts to Find Pi\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        # Move to top edge\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n\n        # 2. SETUP VISUALS (Left Side)\n        # Shift geometry to the left to leave room for text on the right\n        # Square side 5.0, centered at x=-2.5\n        square_center = np.array([-2.5, -0.5, 0])\n        side_len = 5.0\n        radius = side_len / 2.0\n\n        square = Square(side_length=side_len, color=WHITE)\n        square.move_to(square_center)\n        \n        circle = Circle(radius=radius, color=BLUE)\n        circle.move_to(square_center)\n\n        self.play(Create(square), Create(circle))\n        self.wait(1)\n\n        # 3. EXPLAIN GEOMETRY\n        # Show labels for the shapes\n        # Use simple text to explain area ratio\n        label_sq = Text(\"Area = (2r)\u00b2 = 4r\u00b2\", font_size=24, color=WHITE)\n        label_sq.next_to(square, UP, buff=0.2)\n        \n        label_circ = Text(\"Area = \u03c0r\u00b2\", font_size=24, color=BLUE)\n        label_circ.move_to(square_center)\n\n        self.play(Write(label_sq))\n        self.play(Write(label_circ))\n        self.wait(1.5)\n\n        # Transition to Formula\n        # \"Ratio = Area Circle / Area Square = \u03c0 / 4\"\n        ratio_text = Text(\"Ratio = \u03c0 / 4\", font_size=36, color=YELLOW)\n        ratio_text.move_to(np.array([3.5, 1.5, 0])) # Right side\n        \n        pi_iso = Text(\"Therefore: \u03c0 = 4 \u00d7 Ratio\", font_size=36, color=YELLOW)\n        pi_iso.next_to(ratio_text, DOWN, buff=0.5)\n\n        self.play(Write(ratio_text))\n        self.play(Write(pi_iso))\n        self.wait(2)\n\n        # Clean up labels to make room for dots\n        self.play(\n            FadeOut(label_sq),\n            FadeOut(label_circ),\n            FadeOut(ratio_text),\n            pi_iso.animate.move_to(np.array([3.5, 2.5, 0])).scale(1.1)\n        )\n\n        # 4. SETUP COUNTERS (Right Side)\n        # Fixed positions for updates\n        counter_x = 3.5\n        base_y = 1.0\n        \n        # Static labels\n        lbl_total = Text(\"Total Points:\", font_size=32).move_to(np.array([counter_x, base_y, 0]))\n        lbl_inside = Text(\"Inside Circle:\", font_size=32).next_to(lbl_total, DOWN, buff=0.5)\n        lbl_estim = Text(\"Estimation:\", font_size=32).next_to(lbl_inside, DOWN, buff=0.8)\n\n        # Dynamic value placeholders\n        val_total = Text(\"0\", font_size=32).next_to(lbl_total, RIGHT)\n        val_inside = Text(\"0\", font_size=32, color=GREEN).next_to(lbl_inside, RIGHT)\n        val_estim = Text(\"0.00000\", font_size=40, color=YELLOW).next_to(lbl_estim, DOWN, buff=0.3)\n\n        self.play(\n            Write(lbl_total), Write(val_total),\n            Write(lbl_inside), Write(val_inside),\n            Write(lbl_estim), Write(val_estim)\n        )\n\n        # 5. SIMULATION LOOP\n        total_count = 0\n        inside_count = 0\n        \n        # Phase 1: Slow points (explain Red/Green)\n        dots_group = VGroup() # Keep track of dots to morph later\n        \n        for i in range(10):\n            # Generate random point inside square bounds\n            # Square is centered at [-2.5, -0.5], side 5\n            # x range: [-5.0, 0.0], y range: [-3.0, 2.0]\n            rx = random.uniform(-5.0, 0.0)\n            ry = random.uniform(-3.0, 2.0)\n            point = np.array([rx, ry, 0])\n            \n            # Check distance to center\n            dist = np.linalg.norm(point - square_center)\n            is_inside = dist <= radius\n            \n            color = GREEN if is_inside else RED\n            dot = Dot(point, color=color, radius=0.08)\n            dots_group.add(dot)\n            \n            # Update counters logic\n            total_count += 1\n            if is_inside:\n                inside_count += 1\n            \n            estimate = 4.0 * (inside_count / total_count)\n            \n            # Create new text objects\n            new_total = Text(str(total_count), font_size=32).next_to(lbl_total, RIGHT)\n            new_inside = Text(str(inside_count), font_size=32, color=GREEN).next_to(lbl_inside, RIGHT)\n            new_estim = Text(f\"{estimate:.5f}\", font_size=40, color=YELLOW).next_to(lbl_estim, DOWN, buff=0.3)\n            \n            # Animate dot appearance\n            self.play(FadeIn(dot, scale=0.5), run_time=0.2)\n            \n            # Update text (remove old, add new)\n            self.remove(val_total, val_inside, val_estim)\n            self.add(new_total, new_inside, new_estim)\n            \n            # Update references\n            val_total = new_total\n            val_inside = new_inside\n            val_estim = new_estim\n            \n            if i == 0:\n                # Pause on first dot to explain coloring\n                explanation = Text(\"Green if inside, Red if outside\", font_size=24)\n                explanation.next_to(square, DOWN, buff=0.3)\n                self.play(Write(explanation))\n                self.wait(1)\n                self.play(FadeOut(explanation))\n\n        # Phase 2: Speed up (Groups of dots)\n        # We won't animate every single text transform, just bulk updates\n        \n        for batch in range(15):\n            # Add 20 dots at once\n            new_dots = []\n            for _ in range(20):\n                rx = random.uniform(-5.0, 0.0)\n                ry = random.uniform(-3.0, 2.0)\n                point = np.array([rx, ry, 0])\n                dist = np.linalg.norm(point - square_center)\n                is_inside = dist <= radius\n                color = GREEN if is_inside else RED\n                \n                total_count += 1\n                if is_inside:\n                    inside_count += 1\n                \n                d = Dot(point, color=color, radius=0.06)\n                new_dots.append(d)\n                dots_group.add(d)\n            \n            # Show all new dots at once\n            self.add(*new_dots)\n            \n            # Update text once per batch\n            estimate = 4.0 * (inside_count / total_count)\n            new_total = Text(str(total_count), font_size=32).next_to(lbl_total, RIGHT)\n            new_inside = Text(str(inside_count), font_size=32, color=GREEN).next_to(lbl_inside, RIGHT)\n            new_estim = Text(f\"{estimate:.5f}\", font_size=40, color=YELLOW).next_to(lbl_estim, DOWN, buff=0.3)\n            \n            self.remove(val_total, val_inside, val_estim)\n            self.add(new_total, new_inside, new_estim)\n            val_total, val_inside, val_estim = new_total, new_inside, new_estim\n            \n            self.wait(0.1)\n\n        # Phase 3: Blur / Fill (Visual trick)\n        # Instead of adding infinite dots, we fade in a semi-transparent filled circle/square background\n        # to simulate \"filled with dots\"\n        fill_square = Square(side_length=side_len, stroke_opacity=0, fill_color=RED, fill_opacity=0.5)\n        fill_square.move_to(square_center)\n        \n        fill_circle = Circle(radius=radius, stroke_opacity=0, fill_color=GREEN, fill_opacity=1)\n        fill_circle.move_to(square_center)\n        \n        # Update final numbers to a perfect Pi approximation for the finale\n        final_total_num = 10000\n        final_inside_num = 7854\n        final_est_val = 3.14160\n        \n        final_total = Text(str(final_total_num), font_size=32).next_to(lbl_total, RIGHT)\n        final_inside = Text(str(final_inside_num), font_size=32, color=GREEN).next_to(lbl_inside, RIGHT)\n        final_estim = Text(\"3.14159...\", font_size=40, color=YELLOW).next_to(lbl_estim, DOWN, buff=0.3)\n\n        self.play(\n            FadeIn(fill_square),\n            FadeIn(fill_circle),\n            Transform(val_total, final_total),\n            Transform(val_inside, final_inside),\n            Transform(val_estim, final_estim),\n            run_time=2.0\n        )\n        self.wait(2)\n\n        # 6. CONCLUSION\n        # Morph everything into final equation\n        \n        # Define final object\n        final_result = Text(\"\u03c0 \u2248 3.14159\", font_size=72, color=YELLOW).move_to(ORIGIN)\n        \n        # Group all visible elements\n        # Note: We can't group thousands of dots easily if added individually to scene\n        # But we added them to dots_group or scene directly.\n        # Easiest way: Group specific large elements and FadeOut the rest, \n        # or just Transform the main text.\n        \n        # Let's clean visual clutter first\n        self.play(\n            FadeOut(square), FadeOut(circle), \n            FadeOut(fill_square), FadeOut(fill_circle),\n            FadeOut(dots_group),\n            FadeOut(lbl_total), FadeOut(val_total),\n            FadeOut(lbl_inside), FadeOut(val_inside),\n            FadeOut(lbl_estim), FadeOut(title),\n            # Transform the estimate into the final result\n            ReplacementTransform(val_estim, final_result),\n            # Fade out the formula explanation\n            FadeOut(pi_iso)\n        )\n        \n        self.wait(3)\n",
  "estimated_duration": 55
}