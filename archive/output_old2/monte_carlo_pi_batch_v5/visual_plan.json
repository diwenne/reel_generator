{
  "manim_code": "def construct(self):\n    # 1. TITLE INTRO\n    # Title starts at center, then moves up\n    title = Text(\"Throwing Darts to Find Pi\", font_size=56)\n    self.play(Write(title))\n    self.wait(1.5)\n    self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n\n    # 2. SETUP VISUALS\n    # Square side length 5, centered. Circle radius 2.5.\n    # This leaves space on left/right for counters and bottom for formula.\n    side_len = 5.0\n    radius = side_len / 2\n    \n    square = Square(side_length=side_len, color=WHITE)\n    circle = Circle(radius=radius, color=BLUE)\n    \n    # Group them to center properly if needed, though they are at ORIGIN\n    shapes = VGroup(square, circle)\n    \n    self.play(Create(square))\n    self.play(Create(circle))\n    self.wait(1)\n\n    # Labels for shapes\n    lbl_sq = Text(\"Square Area = 4r\u00b2\", font_size=24, color=WHITE).next_to(square, RIGHT, buff=0.5)\n    lbl_circ = Text(\"Circle Area = \u03c0r\u00b2\", font_size=24, color=BLUE).next_to(lbl_sq, DOWN, buff=0.2)\n    \n    self.play(Write(lbl_sq), Write(lbl_circ))\n    self.wait(1)\n    \n    # Remove geometric labels to clear space for simulation\n    self.play(FadeOut(lbl_sq), FadeOut(lbl_circ))\n\n    # 3. SETUP COUNTERS & FORMULA\n    # Place counters on the LEFT side, well away from the square\n    # Square is x from -2.5 to 2.5. We place text at x = -5.0\n    \n    count_label = Text(\"Points: 0\", font_size=36).move_to(LEFT * 5 + UP * 1)\n    inside_label = Text(\"Inside: 0\", font_size=36, color=GREEN).next_to(count_label, DOWN, buff=0.5)\n    \n    # Formula at the BOTTOM, centered\n    # Square bottom is y = -2.5. Text at y = -3.5\n    formula_static = Text(\"\u03c0 \u2248 4 \u00d7 (Inside / Total)\", font_size=40).to_edge(DOWN, buff=0.8)\n    \n    self.play(Write(count_label), Write(inside_label))\n    self.play(Write(formula_static))\n    \n    # Current Estimate Display (below counters)\n    est_label = Text(\"Estimate:\", font_size=36).next_to(inside_label, DOWN, buff=0.8)\n    est_value = Text(\"0.000\", font_size=48, color=YELLOW).next_to(est_label, DOWN, buff=0.2)\n    \n    self.play(Write(est_label), Write(est_value))\n    self.wait(1)\n\n    # 4. SIMULATION LOGIC\n    total_points = 0\n    inside_points = 0\n    \n    # Pre-defined random points for deterministic animation\n    # (Normally we use random, but here we hardcode a few for flow, then loop)\n    import random\n    \n    # Slow phase: show individual dots\n    dots_group = VGroup()\n    \n    for i in range(10):\n        total_points += 1\n        \n        # Random pos within square bounds [-2.5, 2.5]\n        rx = random.uniform(-2.5, 2.5)\n        ry = random.uniform(-2.5, 2.5)\n        point = np.array([rx, ry, 0])\n        \n        # Check distance\n        dist = np.sqrt(rx**2 + ry**2)\n        is_inside = dist <= 2.5\n        \n        dot_color = GREEN if is_inside else RED\n        if is_inside: \n            inside_points += 1\n            \n        dot = Dot(point, color=dot_color, radius=0.08)\n        dots_group.add(dot)\n        \n        # Update Text Objects\n        new_count = Text(f\"Points: {total_points}\", font_size=36).move_to(count_label.get_center())\n        new_inside = Text(f\"Inside: {inside_points}\", font_size=36, color=GREEN).move_to(inside_label.get_center())\n        \n        # Calculate pi estimate\n        val = 4.0 * inside_points / total_points\n        new_est = Text(f\"{val:.3f}\", font_size=48, color=YELLOW).move_to(est_value.get_center())\n        \n        # Animate dot appearing\n        self.play(FadeIn(dot, scale=0.5), run_time=0.3)\n        \n        # Transform text (quick)\n        self.play(\n            Transform(count_label, new_count),\n            Transform(inside_label, new_inside),\n            Transform(est_value, new_est),\n            run_time=0.2\n        )\n        \n        if i < 2: \n            self.wait(0.5) # Wait longer for first few\n\n    # Fast phase: Add many dots without updating text every single time\n    fast_dots = VGroup()\n    for _ in range(100):\n        rx = random.uniform(-2.5, 2.5)\n        ry = random.uniform(-2.5, 2.5)\n        dist = np.sqrt(rx**2 + ry**2)\n        color = GREEN if dist <= 2.5 else RED\n        fast_dots.add(Dot([rx, ry, 0], color=color, radius=0.06))\n        \n    self.play(FadeIn(fast_dots, lag_ratio=0.01), run_time=3)\n    \n    # Update counters to simulated high values\n    # Jump to a \"later\" state\n    total_points = 1500\n    inside_points = 1178 # approx 3.1413\n    \n    final_count = Text(f\"Points: {total_points}\", font_size=36).move_to(count_label.get_center())\n    final_inside = Text(f\"Inside: {inside_points}\", font_size=36, color=GREEN).move_to(inside_label.get_center())\n    final_est = Text(\"3.141\", font_size=48, color=YELLOW).move_to(est_value.get_center())\n    \n    self.play(\n        Transform(count_label, final_count),\n        Transform(inside_label, final_inside),\n        Transform(est_value, final_est)\n    )\n    self.wait(1)\n\n    # 5. CONCEPTUAL FILL\n    # Explain that with infinite dots, we fill the area\n    text_converge = Text(\"As points \u2192 \u221e\", font_size=40, color=BLUE).next_to(square, RIGHT, buff=0.5)\n    self.play(Write(text_converge))\n    \n    # Create filled shapes to represent \"infinite dots\"\n    filled_circle = Circle(radius=2.5, color=GREEN, fill_opacity=0.8, stroke_width=0)\n    filled_corners = Square(side_length=5, color=RED, fill_opacity=0.8, stroke_width=0)\n    # We want the circle on top of the square background, but the square really represents the \"outside\" parts here\n    # So draw red square then green circle on top\n    \n    self.play(FadeIn(filled_corners), FadeIn(filled_circle))\n    self.wait(2)\n    \n    # 6. CONCLUSION\n    # Morph everything into the final result\n    # Clear temporary text\n    \n    # Target: \u03c0 \u2248 3.14159\n    final_result = Text(\"\u03c0 \u2248 3.14159\", font_size=72, color=YELLOW).move_to(ORIGIN)\n    \n    # Group everything currently visible\n    all_objects = VGroup(\n        title, square, circle, dots_group, fast_dots, filled_circle, filled_corners,\n        count_label, inside_label, formula_static, est_label, est_value, text_converge\n    )\n    \n    # Morph!\n    self.play(ReplacementTransform(all_objects, final_result), run_time=2.0)\n    \n    self.wait(3)",
  "estimated_duration": 55
}