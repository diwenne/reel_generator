{
  "manim_code": "class InfiniteSumProof(Scene):\n    def construct(self):\n        # 1. HOOK: Title\n        # Use short, impactful text. Move to top to clear stage.\n        title = Text(\"Why does 1/2 + 1/4 + ... = 1?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        \n        # Move title to top safety zone (y > 3.2)\n        self.play(title.animate.scale(0.8).to_edge(UP, buff=0.4))\n        \n        # 2. SETUP: The Unit Square\n        # Max height 5.0 fits well in center zone (-2.2 < y < 2.8)\n        # Centered slightly up (UP * 0.3)\n        square_side = 5.0\n        main_square = Square(side_length=square_side, color=WHITE)\n        main_square.move_to(UP * 0.3)\n        \n        # Initial label for the whole\n        area_label = Text(\"Area = 1\", font_size=48).move_to(main_square.get_center())\n        \n        self.play(Create(main_square))\n        self.play(Write(area_label))\n        self.wait(1)\n        self.play(FadeOut(area_label))\n\n        # Bottom equation tracking sum\n        # Position in bottom zone (y < -2.7)\n        sum_text = Text(\"Sum: 0\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Write(sum_text))\n\n        # 3. BUILD: Iterative geometric decomposition\n        # We will track the current \"bounds\" of the remaining empty space\n        # Start bounds: x[-2.5, 2.5], y[-2.2, 2.8] (relative to center UP*0.3)\n        \n        # Coordinates of the main square edges\n        left = main_square.get_left()[0]\n        right = main_square.get_right()[0]\n        bottom = main_square.get_bottom()[1]\n        top = main_square.get_top()[1]\n\n        # Lists to store objects for final morph\n        all_parts = VGroup(main_square)\n        all_labels = VGroup()\n\n        # --- STEP 1: The 1/2 (Left Half) ---\n        # Split horizontally\n        mid_x = (left + right) / 2\n        \n        # Create the 1/2 rectangle\n        rect1 = Rectangle(width=(mid_x - left), height=(top - bottom))\n        rect1.set_fill(BLUE, opacity=0.8)\n        rect1.set_stroke(WHITE, width=2)\n        rect1.move_to([ (left + mid_x)/2, (bottom + top)/2, 0 ])\n        \n        label1 = Text(\"1/2\", font_size=56).move_to(rect1.get_center())\n        \n        self.play(DrawBorderThenFill(rect1), run_time=1)\n        self.play(Write(label1))\n        all_parts.add(rect1)\n        all_labels.add(label1)\n\n        # Update Sum\n        sum_text_1 = Text(\"Sum: 0.5\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, sum_text_1))\n        self.wait(1)\n\n        # Update boundaries for next step (we keep the RIGHT side)\n        left = mid_x\n\n        # --- STEP 2: The 1/4 (Top Right) ---\n        # Split vertically\n        mid_y = (bottom + top) / 2\n        \n        rect2 = Rectangle(width=(right - left), height=(top - mid_y))\n        rect2.set_fill(TEAL, opacity=0.8)\n        rect2.set_stroke(WHITE, width=2)\n        rect2.move_to([ (left + right)/2, (mid_y + top)/2, 0 ])\n        \n        label2 = Text(\"1/4\", font_size=48).move_to(rect2.get_center())\n        \n        self.play(FadeIn(rect2, shift=DOWN*0.5))\n        self.play(Write(label2))\n        all_parts.add(rect2)\n        all_labels.add(label2)\n\n        # Update Sum\n        sum_text_2 = Text(\"Sum: 0.75\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, sum_text_2))\n        self.wait(1)\n\n        # Update boundaries (we keep the BOTTOM side)\n        top = mid_y\n\n        # --- STEP 3: The 1/8 (Bottom Right -> Left) ---\n        # Split horizontally\n        mid_x = (left + right) / 2\n        \n        rect3 = Rectangle(width=(mid_x - left), height=(top - bottom))\n        rect3.set_fill(GREEN, opacity=0.8)\n        rect3.set_stroke(WHITE, width=2)\n        rect3.move_to([ (left + mid_x)/2, (bottom + top)/2, 0 ])\n        \n        label3 = Text(\"1/8\", font_size=40).move_to(rect3.get_center())\n        \n        self.play(FadeIn(rect3, shift=RIGHT*0.5))\n        self.play(Write(label3))\n        all_parts.add(rect3)\n        all_labels.add(label3)\n\n        sum_text_3 = Text(\"Sum: 0.875\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, sum_text_3))\n        self.wait(1)\n\n        left = mid_x\n\n        # --- STEP 4: The 1/16 (Bottom Right -> Bottom) ---\n        # Split vertically\n        mid_y = (bottom + top) / 2\n        \n        rect4 = Rectangle(width=(right - left), height=(top - mid_y))\n        rect4.set_fill(YELLOW_D, opacity=0.8)\n        rect4.set_stroke(WHITE, width=2)\n        rect4.move_to([ (left + right)/2, (mid_y + top)/2, 0 ])\n        \n        label4 = Text(\"1/16\", font_size=32).move_to(rect4.get_center())\n        \n        self.play(FadeIn(rect4))\n        self.play(Write(label4))\n        all_parts.add(rect4)\n        all_labels.add(label4)\n\n        sum_text_4 = Text(\"Sum: 0.9375\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, sum_text_4))\n        self.wait(0.5)\n\n        top = mid_y\n\n        # --- RAPID FIRE REMAINING STEPS ---\n        # Just showing the visual fill without specific labels\n        \n        colors = [RED, PURPLE, MAROON, ORANGE]\n        \n        # Update sum text generic\n        sum_text_final_approx = Text(\"Sum \u2192 1\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, sum_text_final_approx))\n\n        for i in range(5):\n            # Determine split direction based on step (even/odd logic relative to start)\n            # Step 1 was X split. Step 2 Y. Step 3 X. Step 4 Y.\n            # So Step 5 is X, Step 6 is Y.\n            \n            if i % 2 == 0:\n                # Split X (Horizontal split, keep right)\n                mid_x = (left + right) / 2\n                new_rect = Rectangle(width=(mid_x - left), height=(top - bottom))\n                new_rect.move_to([ (left + mid_x)/2, (bottom + top)/2, 0 ])\n                left = mid_x\n            else:\n                # Split Y (Vertical split, keep bottom)\n                mid_y = (bottom + top) / 2\n                new_rect = Rectangle(width=(right - left), height=(top - mid_y))\n                new_rect.move_to([ (left + right)/2, (mid_y + top)/2, 0 ])\n                top = mid_y\n            \n            new_rect.set_fill(colors[i % len(colors)], opacity=0.8)\n            new_rect.set_stroke(WHITE, width=1)\n            \n            self.play(Create(new_rect), run_time=0.2)\n            all_parts.add(new_rect)\n        \n        self.wait(1)\n\n        # 4. REVEAL: The Empty Space\n        # Highlight the tiny remaining square\n        remaining_box = Rectangle(width=(right - left), height=(top - bottom), color=RED)\n        remaining_box.move_to([ (left + right)/2, (bottom + top)/2, 0 ])\n        \n        # Arrow pointing to it\n        arrow = Arrow(start=remaining_box.get_center() + RIGHT*2 + UP*1, \n                      end=remaining_box.get_center(), \n                      buff=0.1, color=YELLOW)\n        \n        zero_text = Text(\"Approaches 0\", font_size=40, color=YELLOW)\n        zero_text.next_to(arrow.get_start(), UP, buff=0.1)\n        \n        # Adjust text to stay on screen\n        if zero_text.get_right()[0] > 6.0:\n            zero_text.shift(LEFT * 1.5)\n\n        self.play(GrowArrow(arrow), Write(zero_text))\n        self.play(Create(remaining_box))\n        self.wait(2)\n\n        # 5. CONCLUSION: Morph everything\n        # Final equation centered\n        final_eq = Text(\"1/2 + 1/4 + 1/8 + ... = 1\", font_size=72, color=YELLOW)\n        final_eq.move_to(ORIGIN)\n\n        # Group everything currently visible\n        everything = VGroup(\n            title, \n            all_parts, \n            all_labels, \n            sum_text, \n            arrow, \n            zero_text, \n            remaining_box\n        )\n\n        self.play(\n            ReplacementTransform(everything, final_eq),\n            run_time=2.0\n        )\n        \n        self.wait(3)",
  "estimated_duration": 65
}