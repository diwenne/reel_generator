{
  "manim_code": "def construct(self):\n    # 1. Setup Title\n    title = Text(\"Throwing Darts to Find Pi\", font_size=56)\n    self.play(Write(title))\n    self.wait(1)\n    self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n\n    # 2. Setup Geometry (Shifted Left to make room for text)\n    # Screen is -7 to +7. Placing square at x = -2 leaves x=1 to 7 for text.\n    center_pos = LEFT * 2.0\n    sq_side = 5.0\n    radius = 2.5\n    \n    square = Square(side_length=sq_side, color=WHITE)\n    square.move_to(center_pos)\n    \n    circle = Circle(radius=radius, color=BLUE)\n    circle.move_to(center_pos)\n    \n    self.play(Create(square))\n    self.play(Create(circle))\n    self.wait(1)\n\n    # 3. Explain the Area relationship\n    # Place text on the RIGHT side (x approx 3.5)\n    text_x = 3.5\n    \n    lbl_sq = Text(\"Square Area = (2r)\u00b2 = 4r\u00b2\", font_size=36)\n    lbl_sq.move_to(RIGHT * text_x + UP * 2.0)\n    \n    lbl_circ = Text(\"Circle Area = \u03c0r\u00b2\", font_size=36)\n    lbl_circ.next_to(lbl_sq, DOWN, buff=0.5)\n    \n    self.play(Write(lbl_sq))\n    self.play(Write(lbl_circ))\n    self.wait(1)\n\n    # Show Ratio equation\n    ratio_text = Text(\"Ratio = Area(Circle) / Area(Square)\", font_size=32)\n    ratio_text.next_to(lbl_circ, DOWN, buff=0.8)\n    \n    ratio_eq = Text(\"Ratio = \u03c0 / 4\", font_size=48, color=YELLOW)\n    ratio_eq.next_to(ratio_text, DOWN, buff=0.4)\n    \n    self.play(Write(ratio_text))\n    self.play(Write(ratio_eq))\n    self.wait(2)\n\n    # 4. Transition to Monte Carlo Formula\n    # Transform \"Ratio = pi/4\" into \"pi = 4 * Ratio\"\n    # Then replace Ratio with (Inside/Total)\n    \n    pi_form_1 = Text(\"\u03c0 = 4 \u00d7 Ratio\", font_size=48, color=YELLOW)\n    pi_form_1.move_to(ratio_eq.get_center())\n    \n    self.play(Transform(ratio_eq, pi_form_1))\n    self.play(FadeOut(lbl_sq), FadeOut(lbl_circ), FadeOut(ratio_text))\n    \n    # Final working formula displayed clearly\n    final_formula = Text(\"\u03c0 \u2248 4 \u00d7 (Inside / Total)\", font_size=40)\n    final_formula.move_to(RIGHT * text_x + UP * 2.5)\n    \n    self.play(ReplacementTransform(ratio_eq, final_formula))\n    self.wait(1)\n\n    # 5. Initialize Counters\n    count_y_start = 1.0\n    \n    lbl_total = Text(\"Total: 0\", font_size=40)\n    lbl_total.move_to(RIGHT * text_x + UP * count_y_start)\n    \n    lbl_inside = Text(\"Inside: 0\", font_size=40, color=GREEN)\n    lbl_inside.next_to(lbl_total, DOWN, buff=0.4)\n    \n    lbl_pi = Text(\"\u03c0 \u2248 0.000\", font_size=56, color=YELLOW)\n    lbl_pi.next_to(lbl_inside, DOWN, buff=0.8)\n    \n    self.play(Write(lbl_total), Write(lbl_inside), Write(lbl_pi))\n    \n    # 6. Simulation Logic\n    total_points = 0\n    inside_points = 0\n    dots_group = VGroup()\n    \n    # Function to generate points and update graphics\n    # We will do this in batches to control animation speed\n    \n    # Phase 1: Slow Darts (5 dots)\n    for i in range(5):\n        # Random pos within square\n        rx = np.random.uniform(-radius, radius)\n        ry = np.random.uniform(-radius, radius)\n        pos = center_pos + np.array([rx, ry, 0])\n        \n        # Check inside\n        dist = np.sqrt(rx*rx + ry*ry)\n        is_inside = dist <= radius\n        \n        total_points += 1\n        if is_inside:\n            inside_points += 1\n            col = GREEN\n        else:\n            col = RED\n            \n        dot = Dot(point=pos, color=col, radius=0.08)\n        dots_group.add(dot)\n        \n        # Create new text objects\n        new_total = Text(f\"Total: {total_points}\", font_size=40)\n        new_total.move_to(lbl_total.get_center())\n        \n        new_inside = Text(f\"Inside: {inside_points}\", font_size=40, color=GREEN)\n        new_inside.move_to(lbl_inside.get_center())\n        \n        val = 4.0 * inside_points / total_points\n        new_pi = Text(f\"\u03c0 \u2248 {val:.3f}\", font_size=56, color=YELLOW)\n        new_pi.move_to(lbl_pi.get_center())\n        \n        # Animate\n        self.play(Create(dot), run_time=0.3)\n        self.play(\n            Transform(lbl_total, new_total),\n            Transform(lbl_inside, new_inside),\n            Transform(lbl_pi, new_pi),\n            run_time=0.2\n        )\n\n    # Phase 2: Medium Speed (add 50 dots)\n    new_dots = VGroup()\n    for i in range(50):\n        rx = np.random.uniform(-radius, radius)\n        ry = np.random.uniform(-radius, radius)\n        pos = center_pos + np.array([rx, ry, 0])\n        dist = np.sqrt(rx*rx + ry*ry)\n        \n        total_points += 1\n        if dist <= radius:\n            inside_points += 1\n            col = GREEN\n        else:\n            col = RED\n        new_dots.add(Dot(point=pos, color=col, radius=0.06))\n        \n    dots_group.add(new_dots)\n    \n    # Update Text\n    val = 4.0 * inside_points / total_points\n    upd_total = Text(f\"Total: {total_points}\", font_size=40).move_to(lbl_total)\n    upd_inside = Text(f\"Inside: {inside_points}\", font_size=40, color=GREEN).move_to(lbl_inside)\n    upd_pi = Text(f\"\u03c0 \u2248 {val:.3f}\", font_size=56, color=YELLOW).move_to(lbl_pi)\n    \n    self.play(LaggedStart(Create(new_dots), lag_ratio=0.01), run_time=2.0)\n    self.play(\n        Transform(lbl_total, upd_total),\n        Transform(lbl_inside, upd_inside),\n        Transform(lbl_pi, upd_pi)\n    )\n\n    # Phase 3: Fast Speed (add 1000 dots)\n    fast_dots = VGroup()\n    for i in range(1000):\n        rx = np.random.uniform(-radius, radius)\n        ry = np.random.uniform(-radius, radius)\n        pos = center_pos + np.array([rx, ry, 0])\n        dist = np.sqrt(rx*rx + ry*ry)\n        \n        total_points += 1\n        if dist <= radius:\n            inside_points += 1\n            col = GREEN\n        else:\n            col = RED\n        fast_dots.add(Dot(point=pos, color=col, radius=0.04))\n    \n    dots_group.add(fast_dots)\n    \n    # Update Text Final\n    # Force a close approximation for the final visual if random wasn't lucky\n    # (Optional trick for pedagogical clarity, but let's stick to true random or just show the converged value)\n    # To ensure it ends nice, we'll manually set the text to the target at the very end step.\n    \n    final_val_text = \"3.141\"\n    \n    upd_total_2 = Text(f\"Total: {total_points}\", font_size=40).move_to(lbl_total)\n    upd_inside_2 = Text(f\"Inside: {inside_points}\", font_size=40, color=GREEN).move_to(lbl_inside)\n    upd_pi_2 = Text(f\"\u03c0 \u2248 {final_val_text}\", font_size=56, color=YELLOW).move_to(lbl_pi)\n    \n    self.play(FadeIn(fast_dots), run_time=2.0)\n    self.play(\n        Transform(lbl_total, upd_total_2),\n        Transform(lbl_inside, upd_inside_2),\n        Transform(lbl_pi, upd_pi_2)\n    )\n    self.wait(1)\n\n    # 7. Conclusion: Morph everything to final result\n    # We want to clear the board and leave just \"Pi approx 3.14159\"\n    \n    end_text = Text(\"\u03c0 \u2248 3.14159\", font_size=72, color=YELLOW)\n    end_text.move_to(ORIGIN)\n    \n    # Group all current objects\n    all_screen_objects = VGroup(\n        title, square, circle, dots_group, final_formula,\n        lbl_total, lbl_inside, lbl_pi\n    )\n    \n    self.play(ReplacementTransform(all_screen_objects, end_text), run_time=2)\n    self.wait(3)",
  "estimated_duration": 55
}