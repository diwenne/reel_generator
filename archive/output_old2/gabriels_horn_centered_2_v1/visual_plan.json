{
  "manim_code": "import numpy as np\nfrom manim import *\n\nclass GabrielsHorn(Scene):\n    def construct(self):\n        # 1. HOOK: Title starts center, moves up\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n\n        # 2. STEP 1: Function 1/x (Centered)\n        # Build fraction manually as requested\n        y_label = Text(\"y =\", font_size=60)\n        num = Text(\"1\", font_size=60)\n        bar = Line(LEFT, RIGHT).set_length(0.8).set_stroke(width=4)\n        den = Text(\"x\", font_size=60)\n        \n        # Arrange fraction\n        num.next_to(bar, UP, buff=0.15).set_x(bar.get_x())\n        den.next_to(bar, DOWN, buff=0.15).set_x(bar.get_x())\n        fraction = VGroup(num, bar, den)\n        \n        # Arrange equation\n        fraction.next_to(y_label, RIGHT, buff=0.3)\n        equation = VGroup(y_label, fraction).move_to(ORIGIN)\n        \n        self.play(Write(equation))\n        self.wait(1.5)\n\n        # 3. STEP 2: Transition to Graph\n        # Define visual constants\n        # Shift origin slightly left to fit long horn\n        graph_origin = LEFT * 3.5 + DOWN * 0.5\n        x_scale = 1.2\n        y_scale = 2.5\n        \n        # Function to map math coords to screen coords\n        def coords(x, y):\n            return graph_origin + np.array([x * x_scale, y * y_scale, 0])\n\n        # Prepare axes lines (No Axes class to avoid Tex)\n        x_axis = Line(coords(1, 0) + LEFT, coords(8, 0), color=GRAY)\n        y_axis = Line(coords(1, -1.5), coords(1, 1.5), color=GRAY)\n        tick_line = Line(coords(1, 0.1), coords(1, -0.1), color=WHITE)\n        tick_text = Text(\"x=1\", font_size=32).next_to(tick_line, DOWN, buff=0.2)\n        \n        axes_group = VGroup(x_axis, y_axis, tick_line, tick_text)\n\n        # Generate points for curves\n        x_vals = np.linspace(1, 7.5, 100)\n        top_pts = [coords(x, 1/x) for x in x_vals]\n        bot_pts = [coords(x, -1/x) for x in x_vals]\n        \n        curve_top = VMobject().set_points_smoothly(top_pts).set_color(BLUE)\n        curve_bot = VMobject().set_points_smoothly(bot_pts).set_color(BLUE)\n        \n        # Label for the curve\n        curve_label = Text(\"y = 1/x\", font_size=36, color=BLUE)\n        curve_label.next_to(coords(2, 0.5), UP, buff=0.5)\n\n        # Transition: Equation fades, axes and curve appear\n        self.play(\n            FadeOut(equation),\n            Create(axes_group),\n            run_time=1\n        )\n        self.play(Create(curve_top), Write(curve_label), run_time=1.5)\n        self.wait(1)\n\n        # 4. STEP 3: Reveal Horn (Solid of Revolution)\n        # Draw bottom curve and ellipses to show 3D volume\n        horn_fill = Polygon(\n            *top_pts,\n            *bot_pts[::-1],\n            color=BLUE,\n            fill_opacity=0.3,\n            stroke_width=0\n        )\n        \n        ellipses = VGroup()\n        for xv in [1, 2.5, 4, 5.5, 7]:\n            center = coords(xv, 0)\n            rad = (1/xv) * y_scale\n            el = Ellipse(width=0.3, height=2*rad, color=WHITE, stroke_width=1).move_to(center)\n            ellipses.add(el)\n\n        self.play(\n            Create(curve_bot),\n            FadeIn(horn_fill),\n            Create(ellipses),\n            run_time=2\n        )\n        self.wait(1)\n\n        # Move graph UP to make space for math\n        full_graph = VGroup(axes_group, curve_top, curve_bot, curve_label, horn_fill, ellipses)\n        self.play(full_graph.animate.scale(0.8).shift(UP * 1.5))\n\n        # 5. STEP 4: Volume Calculus\n        # Centered text logic\n        vol_title = Text(\"Volume by disks: \u03c0 \u222b (1/x)\u00b2 dx\", font_size=40).move_to(DOWN * 0.8)\n        vol_calc = Text(\"Integral converges to 1\", font_size=36, color=GRAY).next_to(vol_title, DOWN, buff=0.2)\n        vol_res = Text(\"Volume = \u03c0 \u00d7 1 = \u03c0\", font_size=48, color=GREEN).next_to(vol_calc, DOWN, buff=0.2)\n        \n        vol_group = VGroup(vol_title, vol_calc, vol_res)\n        \n        self.play(Write(vol_title))\n        self.wait(1)\n        self.play(Write(vol_calc))\n        self.play(Write(vol_res))\n        self.wait(2)\n        \n        # Fade out volume for Surface Area\n        self.play(FadeOut(vol_group))\n\n        # 6. STEP 5: Surface Area Calculus\n        # Using Unicode sqrt (\u221a) and integral (\u222b)\n        sa_title = Text(\"Surface Area: 2\u03c0 \u222b (1/x) \u221a(1 + ...) dx\", font_size=36).move_to(DOWN * 0.8)\n        sa_calc = Text(\"Integral diverges\", font_size=36, color=GRAY).next_to(sa_title, DOWN, buff=0.2)\n        sa_res = Text(\"Surface Area = \u221e\", font_size=48, color=RED).next_to(sa_calc, DOWN, buff=0.2)\n        \n        sa_group = VGroup(sa_title, sa_calc, sa_res)\n        \n        self.play(Write(sa_title))\n        self.wait(1)\n        self.play(Write(sa_calc))\n        self.play(Write(sa_res))\n        self.wait(2)\n        \n        # 7. STEP 6: Interpretation\n        self.play(FadeOut(sa_group))\n        \n        interp = Text(\"Finite volume does not require\", font_size=40).move_to(DOWN * 1.5)\n        interp2 = Text(\"finite surface area.\", font_size=40).next_to(interp, DOWN, buff=0.2)\n        interp_group = VGroup(interp, interp2)\n        \n        self.play(Write(interp_group))\n        self.wait(3)\n\n        # 8. FINAL: Morph to Conclusion\n        final_title = Text(\"Gabriel's Horn\", font_size=72, color=BLUE).to_edge(UP, buff=2.0)\n        final_stats = Text(\"V = \u03c0  ,  Surface Area = \u221e\", font_size=60, color=YELLOW)\n        final_stats.next_to(final_title, DOWN, buff=0.8)\n        \n        # Gather all visible items\n        all_visible = VGroup(title, full_graph, interp_group)\n        \n        self.play(\n            ReplacementTransform(all_visible, VGroup(final_title, final_stats)),\n            run_time=2\n        )\n        self.wait(3)",
  "estimated_duration": 60
}