{
  "manim_code": "class GabrielsHorn(Scene):\n    def construct(self):\n        # 1. SETUP TITLES & AXES\n        # Title starts centered\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        \n        # Move title to top\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n        \n        # Define Screen Mapping\n        # Map math_x [1, 10] to screen_x [-5, 5]\n        # Map math_y [1/x] to screen_y (scaled by 3)\n        def get_coords(math_x):\n            screen_x = (math_x - 1) * (10 / 9) - 5\n            screen_y = 3 / math_x\n            return np.array([screen_x, screen_y, 0])\n\n        def get_coords_neg(math_x):\n            v = get_coords(math_x)\n            return np.array([v[0], -v[1], 0])\n\n        # 2. DRAW THE CURVE (2D Cross Section)\n        # Create points for top and bottom curves\n        x_values = np.linspace(1, 10, 100)\n        top_points = [get_coords(x) for x in x_values]\n        bottom_points = [get_coords_neg(x) for x in x_values]\n\n        top_curve = VMobject(color=BLUE).set_points_smoothly(top_points)\n        bottom_curve = VMobject(color=BLUE).set_points_smoothly(bottom_points)\n        \n        # Draw axes (visual only)\n        axis_line = Line(start=np.array([-5.5, 0, 0]), end=np.array([5.5, 0, 0]), color=GRAY, stroke_width=2)\n        label_x = Text(\"x\", font_size=24, color=GRAY).next_to(axis_line, DOWN)\n        \n        # Animate drawing the curve\n        self.play(Create(axis_line), FadeIn(label_x))\n        \n        func_label = Text(\"y = 1/x\", font_size=36, color=BLUE).next_to(top_curve, UP, buff=0.1).set_x(-3)\n        self.play(Create(top_curve), Write(func_label))\n        self.wait(1)\n\n        # 3. ROTATION (Make it look 3D)\n        # Add bottom curve and ellipses to simulate rotation\n        ellipses = VGroup()\n        for x_val in [1, 3, 5, 7, 9]:\n            pos = get_coords(x_val)\n            height = 2 * pos[1]\n            # Draw vertical ellipse to show cross section\n            oval = Ellipse(width=0.4, height=height, color=BLUE_A, stroke_width=2)\n            oval.move_to(np.array([pos[0], 0, 0]))\n            ellipses.add(oval)\n\n        rotation_text = Text(\"Rotate around x-axis\", font_size=32, color=GRAY_A).move_to(UP*2.5)\n        self.play(Write(rotation_text))\n        self.play(\n            Create(bottom_curve),\n            Create(ellipses),\n            run_time=2\n        )\n        self.wait(1)\n        self.play(FadeOut(rotation_text), FadeOut(func_label))\n\n        # 4. VOLUME INTUITION\n        # Visualize slicing into disks\n        # Formula: V = integral pi * r^2 dx\n        \n        vol_label = Text(\"Volume = Sum of Disks\", font_size=40, color=GREEN).to_edge(DOWN, buff=1.0)\n        vol_eq = Text(\"V = \u222b \u03c0(1/x)\u00b2 dx = \u03c0\", font_size=48, color=GREEN).to_edge(DOWN, buff=0.3)\n        \n        self.play(Write(vol_label))\n        \n        # Animate a disk sweeping through\n        tracker = ValueTracker(1)\n        disk = Ellipse(width=0.1, height=6, color=GREEN, fill_opacity=0.8)\n        \n        def update_disk(d):\n            x = tracker.get_value()\n            pos = get_coords(x)\n            d.set_height(2 * pos[1])\n            d.move_to(np.array([pos[0], 0, 0]))\n        \n        disk.add_updater(update_disk)\n        self.add(disk)\n        self.play(tracker.animate.set_value(10), run_time=3, rate_func=linear)\n        disk.remove_updater(update_disk)\n        self.remove(disk)\n\n        # Fill the shape to show finite volume\n        horn_poly = Polygon(*top_points, *reversed(bottom_points), color=BLUE, fill_color=GREEN, fill_opacity=0.5, stroke_width=0)\n        self.play(FadeIn(horn_poly), Write(vol_eq))\n        self.wait(2)\n        \n        # Clean up volume text for next section\n        self.play(FadeOut(vol_label), FadeOut(vol_eq), FadeOut(horn_poly))\n\n        # 5. SURFACE AREA INTUITION\n        # Visualize surface rings\n        # Formula: S = integral 2*pi*r dx\n        \n        surf_label = Text(\"Surface = Sum of Rings\", font_size=40, color=RED).to_edge(DOWN, buff=1.0)\n        surf_eq = Text(\"S = \u222b 2\u03c0(1/x) dx = \u221e\", font_size=48, color=RED).to_edge(DOWN, buff=0.3)\n        \n        self.play(Write(surf_label))\n        \n        # Highlight the boundary\n        self.play(top_curve.animate.set_color(RED), bottom_curve.animate.set_color(RED), run_time=1.5)\n        \n        # Show equation breakdown\n        harm_text = Text(\"Like harmonic series 1/x\", font_size=32, color=RED_A).next_to(surf_eq, UP)\n        self.play(Write(surf_eq))\n        self.play(FadeIn(harm_text))\n        self.wait(2)\n        \n        # 6. THE PARADOX\n        # \"Can fill it, but can't paint it\"\n        self.play(FadeOut(surf_label), FadeOut(harm_text))\n        \n        # Shift eq up slightly to make room or just clear\n        self.play(FadeOut(surf_eq))\n\n        # Visual demonstration of the paradox\n        # Fill it GREEN (Volume)\n        horn_fill = Polygon(*top_points, *reversed(bottom_points), color=BLUE, fill_color=GREEN, fill_opacity=0.6, stroke_width=0)\n        \n        # Paint text\n        paradox_1 = Text(\"Paint fills the inside (Finite)\", font_size=36, color=GREEN).move_to(DOWN*2.5)\n        self.play(FadeIn(horn_fill), Write(paradox_1))\n        self.wait(1.5)\n        \n        # Outline RED (Surface)\n        paradox_2 = Text(\"But never covers the surface (Infinite)\", font_size=36, color=RED).move_to(DOWN*3.3)\n        self.play(top_curve.animate.set_color(RED).set_stroke(width=4), \n                  bottom_curve.animate.set_color(RED).set_stroke(width=4), \n                  Write(paradox_2))\n        self.wait(2.5)\n\n        # 7. CONCLUSION\n        # Morph everything to final equation\n        final_eq = Text(\"V = \u03c0,   S = \u221e\", font_size=72, color=YELLOW).move_to(ORIGIN)\n        \n        # Group all visible objects\n        all_objects = VGroup(\n            title, \n            top_curve, bottom_curve, \n            axis_line, ellipses, \n            horn_fill, label_x,\n            paradox_1, paradox_2\n        )\n        \n        self.play(ReplacementTransform(all_objects, final_eq), run_time=2)\n        self.wait(3)\n",
  "estimated_duration": 55
}