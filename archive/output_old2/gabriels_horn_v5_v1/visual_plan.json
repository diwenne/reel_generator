{
  "manim_code": "def construct(self):\n    # 1. HOOK: Title Sequence\n    title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n    self.play(Write(title))\n    self.wait(1.5)\n    \n    # Move title up to valid top zone\n    self.play(title.animate.scale(0.7).to_edge(UP, buff=0.4))\n    self.wait(1)\n\n    # 2. DEFINE THE FUNCTION y = 1/x\n    # Create fraction manually using Text and VGroup\n    y_label = Text(\"y = \", font_size=48)\n    numer = Text(\"1\", font_size=48)\n    div_line = Line(LEFT*0.3, RIGHT*0.3, color=WHITE).set_stroke(width=2)\n    denom = Text(\"x\", font_size=48)\n    fraction = VGroup(numer, div_line, denom).arrange(DOWN, buff=0.1)\n    \n    equation = VGroup(y_label, fraction).arrange(RIGHT, buff=0.2)\n    equation.to_edge(LEFT, buff=1.0).shift(UP * 2)\n    \n    self.play(Write(equation))\n    self.wait(1)\n\n    # 3. DRAW THE GRAPH\n    # Manual axes to ensure full control without Axes class complexity if not needed\n    # But standard NumberPlane/Axes is better for plotting curves\n    axes = Axes(\n        x_range=[0, 8, 1],\n        y_range=[-3, 3, 1],\n        x_length=9,\n        y_length=5,\n        axis_config={\"include_tip\": True, \"color\": GREY}\n    ).move_to(DOWN * 0.5)\n    \n    x_label = Text(\"x\", font_size=36).next_to(axes.x_axis, RIGHT)\n    y_axis_label = Text(\"y\", font_size=36).next_to(axes.y_axis, UP)\n    \n    self.play(Create(axes), Write(x_label), Write(y_axis_label))\n    \n    # Plot 1/x from x=1 to x=7\n    # Note: 1/x at x=1 is 1. We scale this visually.\n    # Using axes.c2p to get points\n    \n    curve_top = axes.plot(lambda x: 1/x, x_range=[1, 7.5], color=BLUE, stroke_width=4)\n    \n    # Mark x=1 line\n    start_line = axes.get_vertical_line(axes.c2p(1, 1), color=WHITE, line_func=Line)\n    start_label = Text(\"x = 1\", font_size=36).next_to(start_line, DOWN)\n    \n    self.play(Create(curve_top), Create(start_line), Write(start_label))\n    self.wait(1)\n\n    # 4. CREATE THE HORN (Visual Rotation)\n    rot_text = Text(\"Rotate around x-axis\", font_size=40, color=ORANGE)\n    rot_text.to_edge(DOWN, buff=0.4)\n    self.play(Write(rot_text))\n    \n    # Visualizing rotation: Show reflection and ellipses\n    curve_bottom = axes.plot(lambda x: -1/x, x_range=[1, 7.5], color=BLUE, stroke_width=4)\n    \n    # Create ellipses to show 3D nature\n    # Ellipse at start (x=1)\n    start_point_top = axes.c2p(1, 1)\n    start_point_bot = axes.c2p(1, -1)\n    center_start = axes.c2p(1, 0)\n    height_start = start_point_top[1] - start_point_bot[1]\n    ellipse_start = Ellipse(width=0.4, height=height_start, color=BLUE).move_to(center_start)\n    \n    # Ellipse at end (x=7.5)\n    end_point_top = axes.c2p(7.5, 1/7.5)\n    end_point_bot = axes.c2p(7.5, -1/7.5)\n    center_end = axes.c2p(7.5, 0)\n    height_end = end_point_top[1] - end_point_bot[1]\n    ellipse_end = Ellipse(width=0.2, height=height_end, color=BLUE).move_to(center_end)\n    \n    self.play(\n        ReplacementTransform(curve_top.copy(), curve_bottom),\n        Create(ellipse_start),\n        Create(ellipse_end),\n        FadeOut(start_line)\n    )\n    self.wait(1)\n\n    # Create a solid shape for filling later\n    horn_fill = VGroup(curve_top, curve_bottom, ellipse_end, ellipse_start)\n    \n    # Update text\n    gabriel_text = Text(\"Gabriel's Horn\", font_size=48, color=CYAN)\n    gabriel_text.move_to(rot_text.get_center())\n    self.play(ReplacementTransform(rot_text, gabriel_text))\n    self.wait(1)\n\n    # 5. VOLUME = PI\n    # Move Gabriel text up slightly to make room\n    self.play(gabriel_text.animate.shift(UP * 1.5).scale(0.8))\n    \n    vol_label = Text(\"Volume = \u03c0\", font_size=48, color=GREEN)\n    vol_label.to_edge(DOWN, buff=1.0)\n    \n    # Fill effect: Create a polygon approximating the area\n    # We need points from top curve and bottom curve reversed\n    # Manim's fill requires a single VMobject usually, or we use opacity on the curves if closed\n    # Let's approximate with a polygon for the fill\n    \n    fill_points = [\n        *curve_top.get_anchors(),\n        *reversed(curve_bottom.get_anchors())\n    ]\n    horn_area = Polygon(*fill_points, color=GREEN, fill_opacity=0.5, stroke_opacity=0)\n    \n    self.play(Write(vol_label))\n    self.play(FadeIn(horn_area))\n    self.wait(2)\n    \n    # 6. SURFACE AREA = INFINITY\n    surf_label = Text(\"Surface Area = \u221e\", font_size=48, color=RED)\n    surf_label.next_to(vol_label, DOWN, buff=0.3)\n    \n    # Highlight surface (curves) in RED\n    self.play(Write(surf_label))\n    self.play(\n        curve_top.animate.set_color(RED),\n        curve_bottom.animate.set_color(RED),\n        ellipse_start.animate.set_color(RED),\n        ellipse_end.animate.set_color(RED),\n        horn_area.animate.set_fill(opacity=0.2) # Dim the volume fill\n    )\n    self.wait(2)\n\n    # 7. PARADOX EXPLANATION\n    # Clear bottom texts to explain\n    paradox_group = VGroup(vol_label, surf_label)\n    \n    # Using SHORT text lines to avoid cutoff\n    p_text1 = Text(\"You can FILL it...\", font_size=40, color=GREEN)\n    p_text1.to_edge(DOWN, buff=1.2)\n    \n    p_text2 = Text(\"But never PAINT it!\", font_size=40, color=RED)\n    p_text2.next_to(p_text1, DOWN, buff=0.2)\n    \n    self.play(ReplacementTransform(paradox_group, p_text1))\n    self.wait(1)\n    self.play(Write(p_text2))\n    self.wait(3)\n\n    # 8. CONCLUSION: MORPH EVERYTHING\n    # Final Goal: Title at top, Equation centered\n    \n    final_title = Text(\"Gabriel's Horn\", font_size=60, color=CYAN)\n    final_title.to_edge(UP, buff=0.5)\n    \n    final_result = Text(\"V = \u03c0,  S = \u221e\", font_size=72, color=YELLOW)\n    final_result.move_to(ORIGIN)\n    \n    # Group everything on screen to morph\n    all_objects = VGroup(\n        title, equation, axes, x_label, y_axis_label, \n        curve_top, curve_bottom, ellipse_start, ellipse_end, \n        horn_area, start_label, gabriel_text, p_text1, p_text2\n    )\n    \n    # We need to morph title to final_title, and rest to final_result\n    # But strict rules say 'one element'. I will make a VGroup of final state.\n    \n    final_scene = VGroup(final_title, final_result)\n    \n    self.play(\n        ReplacementTransform(all_objects, final_scene),\n        run_time=2.0\n    )\n    \n    self.wait(3)",
  "estimated_duration": 50
}