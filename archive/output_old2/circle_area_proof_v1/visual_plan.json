{
  "manim_code": "class AreaOfCircle(Scene):\n    def construct(self):\n        # 1. SETUP TITLES & POSITIONS\n        # Use distinct zones: UP for title, CENTER for shapes, DOWN for math\n        title = Text(\"Why is Area = \u03c0r\u00b2?\", font_size=56).to_edge(UP, buff=0.4)\n        self.play(Write(title))\n        self.wait(1)\n\n        # 2. DRAW THE CIRCLE\n        # Radius 1.8 ensures width (pi*r approx 5.6) fits safely on screen\n        R = 1.8\n        circle_center = ORIGIN + UP * 0.5\n        \n        # Create the full circle object first\n        circle_outline = Circle(radius=R, color=BLUE, stroke_width=4).move_to(circle_center)\n        radius_line = Line(circle_center, circle_center + RIGHT * R, color=WHITE)\n        radius_label = Text(\"r\", font_size=40).next_to(radius_line, UP, buff=0.1)\n        \n        circle_group = VGroup(circle_outline, radius_line, radius_label)\n        \n        self.play(Create(circle_outline))\n        self.play(Create(radius_line), Write(radius_label))\n        self.wait(1)\n\n        # 3. CREATE WEDGES (The Dissection)\n        # We simulate the circle using 16 individual sectors\n        num_wedges = 16\n        wedge_angle = TAU / num_wedges\n        wedges = VGroup()\n        \n        # Create wedges in circular formation overlaying the circle\n        for i in range(num_wedges):\n            # Alternate colors for visibility\n            color = TEAL if i % 2 == 0 else BLUE_D\n            start_a = i * wedge_angle\n            \n            wedge = AnnularSector(\n                inner_radius=0, \n                outer_radius=R, \n                angle=wedge_angle, \n                start_angle=start_a, \n                color=color,\n                stroke_width=2,\n                stroke_color=WHITE\n            ).move_to(circle_center)\n            wedges.add(wedge)\n\n        # Transform the outline into the wedges\n        self.play(FadeIn(wedges), FadeOut(circle_outline))\n        self.remove(radius_line, radius_label)\n        self.wait(1)\n\n        explanation = Text(\"Slice into wedges\", font_size=40).to_edge(DOWN, buff=1.0)\n        self.play(Write(explanation))\n        self.wait(1.5)\n\n        # 4. REARRANGE WEDGES (The Unzipping)\n        # We need to move them to a rectangular formation centered on screen\n        rect_group = VGroup()\n        \n        # The total width of the interlocked shape is approx pi * R\n        total_width = PI * R\n        start_x = -total_width / 2\n        wedge_width = total_width / (num_wedges / 2) # approx width of one wedge base\n        \n        # Calculate target positions\n        # We separate them into UP pointing (bottom row) and DOWN pointing (top row)\n        rect_y = -0.5 # Center the shape vertically slightly lower\n        \n        targets = []\n        \n        for i in range(num_wedges):\n            w = wedges[i]\n            target_w = w.copy()\n            \n            # Rotate wedge to vertical alignment\n            # A standard sector starts at 0 (East). \n            # We want the bisector to point UP (90deg) or DOWN (-90deg)\n            current_bisector = (i * wedge_angle) + (wedge_angle / 2)\n            \n            if i % 2 == 0:\n                # Bottom row, pointing UP\n                # Rotate so bisector is 90 deg (PI/2)\n                rotation = (PI/2) - current_bisector\n                target_w.rotate(rotation, about_point=circle_center) # Rotate in place first\n                \n                # Move to position\n                # Col index maps i=0,2,4 -> 0,1,2\n                col = i / 2 \n                new_x = start_x + (col * wedge_width) + (wedge_width/2)\n                target_w.move_to(np.array([new_x, rect_y - (R/2) + 0.2, 0]))\n                \n            else:\n                # Top row, pointing DOWN\n                # Rotate so bisector is -90 deg (-PI/2)\n                rotation = (-PI/2) - current_bisector\n                target_w.rotate(rotation, about_point=circle_center)\n                \n                # Move to position (shifted half step right)\n                col = (i - 1) / 2\n                new_x = start_x + (col * wedge_width) + wedge_width\n                target_w.move_to(np.array([new_x, rect_y + (R/2) - 0.2, 0]))\n            \n            rect_group.add(target_w)\n            targets.append(target_w)\n\n        # Animate the rearrangement\n        self.play(FadeOut(explanation))\n        # Create a clean text for the transformation\n        rearrange_text = Text(\"Rearrange...\", font_size=40).to_edge(DOWN, buff=1.0)\n        self.play(Write(rearrange_text))\n        \n        # Animate movement\n        anims = [Transform(wedges[i], targets[i]) for i in range(num_wedges)]\n        self.play(*anims, run_time=2.5)\n        self.wait(1)\n\n        # 5. VISUALIZE DIMENSIONS\n        # Now we have a bumpy rectangle. Let's label dimensions.\n        \n        # Height is R\n        brace_h = Brace(rect_group, LEFT, buff=0.1)\n        label_h = brace_h.get_text(\"r\", buff=0.1).scale(1.2)\n        \n        # Width is Half Circumference = pi * r\n        # (Since full circumference 2*pi*r was split into top and bottom rows)\n        brace_w = Brace(rect_group, DOWN, buff=0.1)\n        label_w = brace_w.get_text(\"\u03c0r\", buff=0.1).scale(1.2)\n        \n        self.play(Create(brace_h), Write(label_h))\n        self.play(Create(brace_w), Write(label_w))\n        self.wait(1.5)\n\n        # 6. LIMIT ARGUMENT & FORMULA\n        # Fade out rearrangement text, show dimensions text\n        self.play(FadeOut(rearrange_text))\n        \n        # Show the idealized Rectangle shape fading in over the bumpy one\n        ideal_rect = Rectangle(width=total_width, height=R, color=YELLOW, fill_opacity=0.3, stroke_width=0)\n        ideal_rect.move_to(rect_group.get_center())\n        \n        limit_text = Text(\"Approaches a Rectangle\", font_size=40).to_edge(DOWN, buff=1.0)\n        self.play(Write(limit_text))\n        self.play(FadeIn(ideal_rect), run_time=1.5)\n        self.wait(1)\n\n        # Calculation steps in Bottom Zone\n        self.play(FadeOut(limit_text))\n        \n        # Step 1: Base equation\n        eq1 = Text(\"Area = Width \u00d7 Height\", font_size=48).to_edge(DOWN, buff=1.0)\n        self.play(Write(eq1))\n        self.wait(1.5)\n        \n        # Step 2: Substitute\n        eq2 = Text(\"Area = \u03c0r \u00d7 r\", font_size=48).to_edge(DOWN, buff=1.0)\n        self.play(ReplacementTransform(eq1, eq2))\n        self.wait(1.5)\n        \n        # Step 3: Result\n        eq3 = Text(\"Area = \u03c0r\u00b2\", font_size=60, color=YELLOW).to_edge(DOWN, buff=1.0)\n        self.play(ReplacementTransform(eq2, eq3))\n        self.wait(2)\n\n        # 7. FINAL MORPH\n        # Everything morphs into the final centered equation\n        \n        final_result = Text(\"Area = \u03c0r\u00b2\", font_size=72, color=YELLOW).move_to(ORIGIN)\n        \n        # Collect everything visible\n        # title, wedges, braces, labels, ideal_rect, eq3\n        all_objects = VGroup(\n            title, \n            wedges, \n            brace_h, label_h, \n            brace_w, label_w, \n            ideal_rect, \n            eq3\n        )\n        \n        self.play(\n            ReplacementTransform(all_objects, final_result),\n            run_time=2.0\n        )\n        \n        self.wait(3)",
  "estimated_duration": 52
}