{
  "manim_code": "class InfiniteSumProof(Scene):\n    def construct(self):\n        # 1. SETUP TITLES & LAYOUT\n        # Big question hook\n        title = Text(\"Why does 1/2 + 1/4 + 1/8 + ... = 1?\", font_size=48)\n        title.to_edge(UP, buff=0.3)\n        \n        self.play(Write(title), run_time=2)\n        self.wait(1)\n        \n        # Prepare the equation line at the bottom\n        # We will build this string dynamically\n        sum_label = Text(\"Sum =\", font_size=40)\n        sum_label.to_edge(DOWN, buff=0.5).to_edge(LEFT, buff=1.0)\n        \n        self.play(Write(sum_label))\n        \n        # 2. MAIN VISUAL: THE UNIT SQUARE\n        # Position: Center of screen slightly shifted up to clear bottom text\n        # Size: 4x4 units (large enough to see details)\n        square_center = UP * 0.5\n        full_square = Square(side_length=4, color=WHITE, stroke_width=2)\n        full_square.move_to(square_center)\n        \n        # Label for the whole \"1\"\n        one_label = Text(\"Area = 1\", font_size=40)\n        one_label.next_to(full_square, RIGHT, buff=0.5)\n        \n        self.play(Create(full_square))\n        self.play(Write(one_label))\n        self.wait(1)\n        self.play(FadeOut(one_label))\n        \n        # 3. RECURSIVE SUBDIVISION LOOP\n        # We will slice the square repeatedly\n        # Logic: Alternate vertical and horizontal cuts on the *remaining* part\n        \n        # Current bounds of the \"remaining\" rectangle\n        # Relative to the square's center (0,0 is center of 4x4 square)\n        # Local coordinates relative to square_center\n        x_min, x_max = -2.0, 2.0\n        y_min, y_max = -2.0, 2.0\n        \n        colors = [BLUE, TEAL, GREEN, YELLOW, GOLD, ORANGE, RED]\n        fractions = [\"1/2\", \"1/4\", \"1/8\", \"1/16\", \"1/32\", \"1/64\"]\n        \n        current_equation_group = VGroup(sum_label)\n        \n        # Iterate through the first 6 steps\n        for i in range(6):\n            # Determine geometry for this step\n            if i % 2 == 0:\n                # Vertical cut: Keep left half, remainder is right half\n                split_x = (x_min + x_max) / 2\n                # The piece we keep (Left side of current bounds)\n                piece_width = split_x - x_min\n                piece_height = y_max - y_min\n                piece_center_x = x_min + piece_width / 2\n                piece_center_y = (y_min + y_max) / 2\n                \n                # Update bounds for *next* iteration (Right side)\n                x_min = split_x\n                \n            else:\n                # Horizontal cut: Keep top half, remainder is bottom half\n                split_y = (y_min + y_max) / 2\n                # The piece we keep (Top side of current bounds)\n                piece_width = x_max - x_min\n                piece_height = y_max - split_y\n                piece_center_x = (x_min + x_max) / 2\n                piece_center_y = split_y + piece_height / 2\n                \n                # Update bounds for *next* iteration (Bottom side)\n                y_max = split_y\n            \n            # Create the visual rectangle\n            piece = Rectangle(\n                width=piece_width, \n                height=piece_height, \n                color=WHITE, \n                fill_color=colors[i], \n                fill_opacity=0.8\n            )\n            # Position it relative to the global square center\n            piece.move_to(square_center + np.array([piece_center_x, piece_center_y, 0]))\n            \n            # Animate the piece appearing\n            self.play(DrawBorderThenFill(piece), run_time=0.8)\n            \n            # Add label if it fits\n            if i < 4:\n                lbl = Text(fractions[i], font_size=max(20, 48 - i*8), color=BLACK)\n                lbl.move_to(piece.get_center())\n                self.play(Write(lbl), run_time=0.5)\n            \n            # Update the equation at the bottom\n            # We recreate the equation line to ensure proper spacing\n            new_term = Text(f\"+ {fractions[i]}\", font_size=40)\n            if i == 0:\n                new_term = Text(f\"{fractions[i]}\", font_size=40)\n            \n            # Position new term next to the previous group\n            new_term.next_to(current_equation_group, RIGHT, buff=0.2)\n            \n            self.play(Write(new_term))\n            \n            # Add to group for next iteration\n            current_equation_group.add(new_term)\n            \n            # Pause to let the viewer process\n            wait_time = max(0.5, 2.0 - i * 0.3)\n            self.wait(wait_time)\n            \n        # 4. SHOW THE PATTERN CONTINUING\n        # Add ellipses to equation\n        dots = Text(\"+ ...\", font_size=40)\n        dots.next_to(current_equation_group, RIGHT, buff=0.2)\n        self.play(Write(dots))\n        current_equation_group.add(dots)\n        \n        # Fill the tiny remaining space to complete the square visually\n        remaining_rect = Rectangle(\n            width=x_max - x_min, \n            height=y_max - y_min,\n            color=WHITE,\n            fill_color=colors[-1],\n            fill_opacity=0.8\n        )\n        remaining_rect.move_to(square_center + np.array([(x_min + x_max)/2, (y_min + y_max)/2, 0]))\n        \n        self.play(FadeIn(remaining_rect), run_time=1)\n        self.wait(1)\n        \n        # 5. THE AHA MOMENT\n        # Flash the whole square to show it's completely filled\n        full_square_overlay = Square(side_length=4, color=YELLOW, stroke_width=4)\n        full_square_overlay.move_to(square_center)\n        \n        self.play(ShowPassingFlash(full_square_overlay, time_width=0.5, run_time=1.5))\n        self.wait(0.5)\n        \n        # Transform the bottom equation to \"= 1\"\n        equals_one = Text(\"= 1\", font_size=40, color=YELLOW)\n        equals_one.next_to(current_equation_group, RIGHT, buff=0.2)\n        \n        self.play(Write(equals_one))\n        self.wait(2)\n        \n        # 6. DRAMATIC FINALE\n        # Clear everything and show the final truth centered\n        self.play(\n            *[FadeOut(m) for m in self.mobjects],\n            run_time=1.0\n        )\n        \n        final_text = Text(\"1/2 + 1/4 + 1/8 + ... = 1\", font_size=72, color=YELLOW)\n        final_text.move_to(ORIGIN)\n        \n        self.play(Write(final_text), run_time=2)\n        self.wait(3)\n",
  "estimated_duration": 65
}