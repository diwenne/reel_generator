{
  "manim_code": "def construct(self):\n    # 1. TITLE SEQUENCE\n    title = Text(\"How Recursion Works\", font_size=56)\n    self.play(Write(title))\n    self.wait(1.5)\n    self.play(title.animate.scale(0.85).to_edge(UP, buff=0.3))\n\n    # 2. SETUP VISUAL CONSTANTS\n    # We will stack boxes at x = -2 to leave room for calculations on the right\n    x_stack = -2.0\n    y_levels = [2.2, 0.7, -0.8, -2.3]  # Y positions for f(4) down to f(1)\n    box_width = 2.4\n    box_height = 1.0\n    \n    # Lists to track objects for the final morph\n    stack_groups = []\n    arrows = []\n    results = []\n\n    # 3. BUILD THE STACK (GOING DOWN)\n    # We iterate from 4 down to 1\n    input_values = [4, 3, 2, 1]\n    \n    for i, n in enumerate(input_values):\n        # Create the rectangle and label\n        rect = Rectangle(width=box_width, height=box_height, color=BLUE)\n        label = Text(f\"f({n})\", font_size=44)\n        group = VGroup(rect, label).move_to([x_stack, y_levels[i], 0])\n        \n        # Animate appearance\n        self.play(Create(group), run_time=0.8)\n        stack_groups.append(group)\n        \n        # Draw arrow to the next level (if not the last one)\n        if i < len(input_values) - 1:\n            arrow_start = [x_stack, y_levels[i] - box_height/2, 0]\n            arrow_end = [x_stack, y_levels[i+1] + box_height/2, 0]\n            arrow = Arrow(start=arrow_start, end=arrow_end, buff=0.1, color=GRAY)\n            self.play(GrowArrow(arrow), run_time=0.6)\n            arrows.append(arrow)\n        \n        self.wait(0.5)\n\n    # 4. BASE CASE REACHED\n    # Highlight f(1) in Green\n    f1_box = stack_groups[3][0]\n    self.play(f1_box.animate.set_color(GREEN), run_time=0.5)\n    \n    # Show return text\n    base_text = Text(\"Return 1\", font_size=36, color=GREEN).next_to(f1_box, RIGHT, buff=0.4)\n    self.play(Write(base_text))\n    self.wait(1.0)\n    \n    # Simplify \"Return 1\" to just \"1\" for arithmetic\n    val_1 = Text(\"1\", font_size=44, color=GREEN).next_to(f1_box, RIGHT, buff=0.6)\n    self.play(ReplacementTransform(base_text, val_1))\n    self.wait(1.0)\n    results.append(val_1)\n    \n    # 5. UNWINDING THE STACK (GOING UP)\n    # We propagate values up: f(1)->f(2), f(2)->f(3), f(3)->f(4)\n    # Logic: (target_index, n_val, prev_result)\n    unwind_steps = [\n        (2, 2, 1), # f(2) receives 1 from f(1)\n        (1, 3, 2), # f(3) receives 2 from f(2)\n        (0, 4, 6)  # f(4) receives 6 from f(3)\n    ]\n    \n    prev_text_obj = val_1\n    \n    for idx, n, prev_res in unwind_steps:\n        target_group = stack_groups[idx]\n        target_rect = target_group[0]\n        \n        # Highlight the function that is resuming\n        self.play(target_rect.animate.set_color(GREEN), run_time=0.5)\n        \n        # 1. Create a copy of the previous result to move up\n        traveling_val = Text(str(prev_res), font_size=44, color=GREEN)\n        traveling_val.move_to(prev_text_obj.get_center())\n        self.add(traveling_val)\n        \n        # 2. Move it up to the current level\n        target_pos = target_group.get_right() + RIGHT * 1.5\n        self.play(traveling_val.animate.move_to(target_pos), run_time=1.2)\n        \n        # 3. Show the multiplication equation: \"n * prev\"\n        equation_str = f\"{n} x {prev_res}\"\n        equation_text = Text(equation_str, font_size=40, color=GREEN).next_to(target_group, RIGHT, buff=0.4)\n        \n        self.play(ReplacementTransform(traveling_val, equation_text))\n        self.wait(0.8)\n        \n        # 4. Resolve to new result\n        new_res = n * prev_res\n        result_text = Text(str(new_res), font_size=44, color=GREEN).next_to(target_group, RIGHT, buff=0.4)\n        \n        self.play(ReplacementTransform(equation_text, result_text))\n        self.wait(1.2)\n        \n        # Store for next iteration\n        prev_text_obj = result_text\n        results.append(result_text)\n\n    # 6. CONCLUSION\n    # The top result is 24. Morph everything into final statement.\n    \n    final_statement = Text(\"4! = 24\", font_size=72, color=YELLOW).move_to(ORIGIN)\n    \n    # Gather all visible elements\n    all_visible = VGroup(title, *stack_groups, *arrows, *results)\n    \n    self.play(ReplacementTransform(all_visible, final_statement), run_time=2.0)\n    self.wait(3.0)",
  "estimated_duration": 42
}