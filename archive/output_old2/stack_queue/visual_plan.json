{
  "manim_code": "def construct(self):\n    # HOOK -------------------------------------------------------------\n    title = Text(\"Stack vs Queue\", font_size=48)\n    title.to_edge(UP, buff=0.5)\n    self.play(Write(title), run_time=1.0)\n    self.wait(1.0)\n\n    subtitle = Text(\"Two ways to organize waiting items\", font_size=30, color=GREY)\n    subtitle.move_to(DOWN * 0.2)\n    self.play(Write(subtitle), run_time=0.8)\n    self.wait(0.7)\n\n    # BUILD: basic layouts ----------------------------------------------\n    # Positions\n    stack_center = LEFT * 3 + DOWN * 0.3\n    queue_center = RIGHT * 3 + DOWN * 0.3\n\n    # Stack box frame (vertical box)\n    stack_frame = Rectangle(width=2, height=4, color=BLUE)\n    stack_frame.move_to(stack_center)\n\n    stack_label = Text(\"Stack\", font_size=32, color=BLUE)\n    stack_label.move_to(stack_center + DOWN * 2.6)\n\n    # Queue frame (horizontal box)\n    queue_frame = Rectangle(width=4, height=2, color=RED)\n    queue_frame.move_to(queue_center)\n\n    queue_label = Text(\"Queue\", font_size=32, color=RED)\n    queue_label.move_to(queue_center + DOWN * 2.0)\n\n    self.play(Create(stack_frame), Create(queue_frame), run_time=1.0)\n    self.play(Write(stack_label), Write(queue_label), run_time=0.8)\n    self.wait(0.5)\n\n    # Explain idea text\n    explain = Text(\"Same items, different rules\", font_size=30, color=YELLOW)\n    explain.to_edge(DOWN, buff=0.5)\n    self.play(Write(explain), run_time=0.8)\n    self.wait(0.8)\n\n    # BUILD: Create three items (boxes with labels) ---------------------\n    item_colors = [GREY, GREY, GREY]\n    item_texts = [\"A\", \"B\", \"C\"]\n\n    items_row = VGroup()\n    for i, label_char in enumerate(item_texts):\n        box = Rectangle(width=1, height=0.7, color=WHITE)\n        label = Text(label_char, font_size=28)\n        group = VGroup(box, label)\n        group.move_to(UP * 1 + LEFT * (1.4 - i * 1.4))\n        items_row.add(group)\n\n    self.play(*[Create(group) for group in items_row], run_time=1.0)\n    self.wait(0.5)\n\n    in_label = Text(\"Incoming items\", font_size=26, color=GREY)\n    in_label.move_to(UP * 2)\n    self.play(Write(in_label), run_time=0.7)\n    self.wait(0.5)\n\n    # REVEAL: Stack behavior (LIFO) -------------------------------------\n    lifo_text = Text(\"Stack: LIFO (Last In, First Out)\", font_size=28, color=BLUE)\n    lifo_text.to_corner(UL)\n    self.play(Write(lifo_text), run_time=0.8)\n\n    # Push A, B, C onto stack (from left to right)\n    stack_slots_y = [stack_center[1] - 1.0, stack_center[1], stack_center[1] + 1.0]\n    stack_x = stack_center[0]\n\n    # Push A\n    self.play(\n        items_row[0].animate.move_to([stack_x, stack_slots_y[0], 0]),\n        run_time=0.7,\n    )\n    # Push B\n    self.play(\n        items_row[1].animate.move_to([stack_x, stack_slots_y[1], 0]),\n        run_time=0.7,\n    )\n    # Push C (last in, on top)\n    self.play(\n        items_row[2].animate.move_to([stack_x, stack_slots_y[2], 0]),\n        run_time=0.7,\n    )\n    self.wait(0.7)\n\n    # Arrow showing access from top\n    stack_arrow = Arrow(\n        start=stack_center + UP * 2.3,\n        end=stack_center + UP * 1.3,\n        color=YELLOW,\n    )\n    access_top = Text(\"Only use the top\", font_size=24, color=YELLOW)\n    access_top.move_to(stack_center + UP * 2.8)\n    self.play(Create(stack_arrow), Write(access_top), run_time=0.8)\n    self.wait(0.5)\n\n    # Pop sequence: C, then B, then A\n    pop_positions = [LEFT * 0.5 + DOWN * 1.8, LEFT * 0.8 + DOWN * 1.8, LEFT * 1.1 + DOWN * 1.8]\n\n    self.play(\n        items_row[2].animate.move_to(pop_positions[0]),\n        run_time=0.6,\n    )\n    self.play(\n        items_row[1].animate.move_to(pop_positions[1]),\n        run_time=0.6,\n    )\n    self.play(\n        items_row[0].animate.move_to(pop_positions[2]),\n        run_time=0.6,\n    )\n    self.wait(0.9)\n\n    order_stack = Text(\"Out order: C, B, A\", font_size=26, color=GREEN)\n    order_stack.move_to(DOWN * 2.4 + LEFT * 2.5)\n    self.play(Write(order_stack), run_time=0.7)\n    self.wait(1.0)\n\n    # Clear stack-specific indicators for transition --------------------\n    self.play(FadeOut(stack_arrow), FadeOut(access_top), run_time=0.5)\n\n    # BUILD: Reset items for queue demonstration ------------------------\n    # Move items back above, same A,B,C from left to right\n    self.play(\n        items_row[0].animate.move_to(UP * 1 + LEFT * 1.4),\n        items_row[1].animate.move_to(UP * 1 + ORIGIN),\n        items_row[2].animate.move_to(UP * 1 + RIGHT * 1.4),\n        FadeOut(order_stack),\n        run_time=0.8,\n    )\n\n    # REVEAL: Queue behavior (FIFO) -------------------------------------\n    fifo_text = Text(\"Queue: FIFO (First In, First Out)\", font_size=28, color=RED)\n    fifo_text.to_corner(UR)\n    self.play(Write(fifo_text), run_time=0.8)\n\n    # Arrows for queue: entry on left, exit on right\n    enter_arrow = Arrow(\n        start=queue_center + LEFT * 3,\n        end=queue_center + LEFT * 2.3,\n        color=YELLOW,\n    )\n    exit_arrow = Arrow(\n        start=queue_center + RIGHT * 2.3,\n        end=queue_center + RIGHT * 3,\n        color=YELLOW,\n    )\n    enter_label = Text(\"Enter here\", font_size=22, color=YELLOW)\n    enter_label.move_to(queue_center + LEFT * 3 + UP * 0.7)\n    exit_label = Text(\"Leave here\", font_size=22, color=YELLOW)\n    exit_label.move_to(queue_center + RIGHT * 3 + UP * 0.7)\n\n    self.play(\n        Create(enter_arrow), Create(exit_arrow),\n        Write(enter_label), Write(exit_label),\n        run_time=0.8,\n    )\n    self.wait(0.3)\n\n    # Enqueue A, B, C: A goes in first at left, then B, then C\n    queue_y = queue_center[1]\n    queue_slots_x = [queue_center[0] - 1.0, queue_center[0], queue_center[0] + 1.0]\n\n    # Enqueue A\n    self.play(\n        items_row[0].animate.move_to([queue_slots_x[0], queue_y, 0]),\n        run_time=0.6,\n    )\n    # Enqueue B\n    self.play(\n        items_row[1].animate.move_to([queue_slots_x[1], queue_y, 0]),\n        run_time=0.6,\n    )\n    # Enqueue C\n    self.play(\n        items_row[2].animate.move_to([queue_slots_x[2], queue_y, 0]),\n        run_time=0.6,\n    )\n    self.wait(0.6)\n\n    # Dequeue sequence: from left to right: A, B, C\n    out_base_y = DOWN * 2.4\n    self.play(\n        items_row[0].animate.move_to(queue_center + RIGHT * 3.2 + out_base_y),\n        run_time=0.6,\n    )\n    self.play(\n        items_row[1].animate.move_to(queue_center + RIGHT * 3.2 + out_base_y + DOWN * 0.5),\n        run_time=0.6,\n    )\n    self.play(\n        items_row[2].animate.move_to(queue_center + RIGHT * 3.2 + out_base_y + DOWN * 1.0),\n        run_time=0.6,\n    )\n    self.wait(0.7)\n\n    order_queue = Text(\"Out order: A, B, C\", font_size=26, color=GREEN)\n    order_queue.move_to(DOWN * 2.4 + RIGHT * 2.5)\n    self.play(Write(order_queue), run_time=0.7)\n    self.wait(1.2)\n\n    # REINFORCE: Side-by-side comparison text ---------------------------\n    self.play(\n        FadeOut(in_label),\n        FadeOut(enter_arrow), FadeOut(exit_arrow),\n        FadeOut(enter_label), FadeOut(exit_label),\n        run_time=0.6,\n    )\n\n    compare1 = Text(\"Stack: last in \u2192 first out\", font_size=28, color=BLUE)\n    compare2 = Text(\"Queue: first in \u2192 first out\", font_size=28, color=RED)\n    compare_group = VGroup(compare1, compare2)\n    compare_group.arrange(DOWN, center=True, buff=0.4)\n    compare_group.to_edge(DOWN, buff=0.5)\n\n    self.play(ReplacementTransform(explain, compare_group), run_time=0.8)\n    self.wait(2.0)\n\n    # CONCLUDE ----------------------------------------------------------\n    summary = Text(\"Same boxes, different rules \u2192 different behavior\", font_size=30, color=GREEN)\n    summary.move_to(ORIGIN + DOWN * 0.2)\n\n    self.play(\n        FadeOut(items_row),\n        FadeOut(order_queue),\n        FadeOut(stack_frame), FadeOut(queue_frame),\n        FadeOut(stack_label), FadeOut(queue_label),\n        FadeOut(lifo_text), FadeOut(fifo_text),\n        FadeOut(subtitle),\n        run_time=0.8,\n    )\n    self.play(Write(summary), run_time=1.0)\n    self.wait(2.0)\n\n    self.play(FadeOut(summary), FadeOut(compare_group), FadeOut(title), run_time=0.8)\n    self.wait(1.0)",
  "estimated_duration": 50
}