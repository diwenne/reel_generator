{
  "manim_code": "class InfiniteSumProof(Scene):\n    def construct(self):\n        # 1. SETUP TITLES & LAYOUT\n        # Strict spacing: Title at top, Equation at bottom, Shapes in center\n        title = Text(\"Why does 1/2 + 1/4 + 1/8 + ... = 1?\", font_size=48)\n        title.to_edge(UP, buff=0.5)\n        \n        # Initialize sum equation at bottom\n        sum_label = Text(\"Sum = 0\", font_size=48)\n        sum_label.to_edge(DOWN, buff=0.5)\n\n        # 2. INTRODUCE THE UNIT SQUARE\n        self.play(Write(title))\n        self.wait(1)\n\n        # Main square centered slightly up to balance the vertical space\n        # Size 5x5 ensures good visibility without crowding title/footer\n        square_center = UP * 0.5\n        full_square = Square(side_length=5, color=WHITE)\n        full_square.move_to(square_center)\n        \n        area_label = Text(\"Area = 1\", font_size=42)\n        area_label.move_to(square_center)\n\n        self.play(Create(full_square))\n        self.play(Write(area_label))\n        self.wait(1.5)\n        self.play(FadeOut(area_label))\n\n        # 3. GEOMETRIC SPIRAL ANIMATION\n        # We will dynamically slice the square\n        # Bounds: [x_min, x_max, y_min, y_max]\n        # Initial relative to center 0,0 (will shift by square_center later)\n        bounds = [-2.5, 2.5, -2.5, 2.5] \n        \n        rects_group = VGroup(full_square)\n        equation_text = \"Sum = \"\n        fractions = [\"1/2\", \"1/4\", \"1/8\", \"1/16\", \"1/32\", \"1/64\"]\n        colors = [BLUE, TEAL, GREEN, YELLOW, GOLD, RED]\n        \n        # Current sum string for the bottom label\n        current_sum_str = \"Sum = \"\n\n        for i in range(6):\n            fraction_text = fractions[i]\n            color = colors[i]\n            \n            # Calculate dimensions of current bounds\n            width = bounds[1] - bounds[0]\n            height = bounds[3] - bounds[2]\n            \n            # Determine slice based on spiral pattern: Left, Top, Right, Bottom\n            # 0: Left Half (Vertical split)\n            # 1: Top Half (Horizontal split)\n            # 2: Right Half (Vertical split)\n            # 3: Bottom Half (Horizontal split)\n            mode = i % 4\n            \n            new_rect = None\n            text_pos = ORIGIN\n            \n            if mode == 0: # Cut Left\n                rect_width = width / 2\n                rect_height = height\n                # Create rectangle for the left half\n                new_rect = Rectangle(width=rect_width, height=rect_height)\n                # Position: x is left bound + half width\n                center_x = bounds[0] + rect_width / 2\n                center_y = bounds[2] + height / 2\n                new_rect.move_to(np.array([center_x, center_y, 0]) + square_center)\n                # Update bounds for remaining part (Right side remains)\n                bounds[0] += rect_width\n                \n            elif mode == 1: # Cut Top\n                rect_width = width\n                rect_height = height / 2\n                new_rect = Rectangle(width=rect_width, height=rect_height)\n                # Position: y is top bound - half height\n                center_x = bounds[0] + width / 2\n                center_y = bounds[3] - rect_height / 2\n                new_rect.move_to(np.array([center_x, center_y, 0]) + square_center)\n                # Update bounds (Bottom side remains)\n                bounds[3] -= rect_height\n                \n            elif mode == 2: # Cut Right\n                rect_width = width / 2\n                rect_height = height\n                new_rect = Rectangle(width=rect_width, height=rect_height)\n                # Position: x is right bound - half width\n                center_x = bounds[1] - rect_width / 2\n                center_y = bounds[2] + height / 2\n                new_rect.move_to(np.array([center_x, center_y, 0]) + square_center)\n                # Update bounds (Left side remains)\n                bounds[1] -= rect_width\n\n            elif mode == 3: # Cut Bottom\n                rect_width = width\n                rect_height = height / 2\n                new_rect = Rectangle(width=rect_width, height=rect_height)\n                # Position: y is bottom bound + half height\n                center_x = bounds[0] + width / 2\n                center_y = bounds[2] + rect_height / 2\n                new_rect.move_to(np.array([center_x, center_y, 0]) + square_center)\n                # Update bounds (Top side remains)\n                bounds[2] += rect_height\n\n            # Style the rectangle\n            new_rect.set_fill(color, opacity=0.8)\n            new_rect.set_stroke(WHITE, width=2)\n            \n            # Create Label (only for first 4 to avoid clutter)\n            lbl = Text(fraction_text, font_size=40 if i < 3 else 32)\n            if i >= 4: \n                lbl = Text(\"\", font_size=1) # Invisible label for small ones\n            lbl.move_to(new_rect.get_center())\n            \n            # Update equation text\n            separator = \" + \" if i > 0 else \"\"\n            current_sum_str += separator + fraction_text\n            if i == 5:\n                current_sum_str += \" + ...\"\n            \n            new_sum_label = Text(current_sum_str, font_size=36)\n            new_sum_label.to_edge(DOWN, buff=0.5)\n            \n            # Animate this step\n            self.play(\n                Create(new_rect),\n                Write(lbl),\n                Transform(sum_label, new_sum_label),\n                run_time=1.5\n            )\n            rects_group.add(new_rect, lbl)\n            self.wait(0.5)\n\n        # 4. INSIGHT MOMENT\n        # Highlight the tiny remaining space\n        remaining_width = bounds[1] - bounds[0]\n        remaining_height = bounds[3] - bounds[2]\n        remaining_center = np.array([\n            (bounds[0] + bounds[1])/2,\n            (bounds[2] + bounds[3])/2,\n            0\n        ]) + square_center\n        \n        tiny_rect = Rectangle(width=remaining_width, height=remaining_height, color=WHITE)\n        tiny_rect.move_to(remaining_center)\n        \n        insight_text = Text(\"Approaching zero\", font_size=36, color=YELLOW)\n        # Position insight text safely to the right or left depending on space\n        # Since we spiral into center, let's put it to the right of the square\n        insight_text.next_to(full_square, RIGHT, buff=0.5)\n        \n        arrow = Arrow(start=insight_text.get_left(), end=remaining_center, buff=0.1, color=YELLOW)\n        \n        self.play(Create(tiny_rect), FadeIn(insight_text), GrowArrow(arrow))\n        self.wait(2)\n        \n        # Flash the full square to show completeness\n        self.play(Flash(full_square, color=WHITE, line_length=0.5, flash_radius=3.0))\n        self.wait(1)\n\n        # 5. DRAMATIC FINALE\n        # Clear EVERYTHING\n        self.play(\n            FadeOut(rects_group),\n            FadeOut(full_square),\n            FadeOut(title),\n            FadeOut(sum_label),\n            FadeOut(tiny_rect),\n            FadeOut(insight_text),\n            FadeOut(arrow),\n            run_time=1.0\n        )\n        \n        # Show final result big and centered\n        final_eq = Text(\"1/2 + 1/4 + 1/8 + ... = 1\", font_size=72, color=YELLOW)\n        final_eq.move_to(ORIGIN)\n        \n        self.play(Write(final_eq), run_time=2.0)\n        self.wait(4)",
  "estimated_duration": 65
}