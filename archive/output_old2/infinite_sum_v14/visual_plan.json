{
  "manim_code": "import numpy as np\nfrom manim import *\n\nclass InfiniteSumOne(Scene):\n    def construct(self):\n        # 1. HOOK: Title Sequence\n        title = Text(\"Why does 1/2 + 1/4 + 1/8 + ... = 1?\", font_size=56)\n        self.play(Write(title), run_time=2)\n        self.wait(2)\n        \n        # Move title to top to clear the stage\n        self.play(\n            title.animate.scale(0.7).to_edge(UP, buff=0.4),\n            run_time=1.5\n        )\n\n        # 2. SETUP: Main Square\n        # Define square geometry\n        square_side = 4.5\n        # Center y adjusted slightly up to avoid bottom text crowding\n        center_y = 0.2\n        \n        main_square = Square(side_length=square_side, color=WHITE)\n        main_square.move_to(UP * center_y)\n        \n        # Show total area label\n        area_label = Text(\"Total Area = 1\", font_size=40)\n        area_label.next_to(main_square, LEFT, buff=0.5)\n        \n        self.play(Create(main_square), run_time=1.5)\n        self.play(Write(area_label))\n        self.wait(1.5)\n        self.play(FadeOut(area_label))\n\n        # 3. BUILD: Iterative Spirals\n        # We will track coordinates of the 'remaining' empty rectangle\n        x_min = -square_side / 2\n        x_max = square_side / 2\n        y_min = -square_side / 2 + center_y\n        y_max = square_side / 2 + center_y\n\n        # Sum tracker at bottom\n        sum_val = 0.0\n        sum_text = Text(\"Sum: 0\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Write(sum_text))\n\n        # Group to hold all pieces for final morph\n        pieces = VGroup()\n        labels = VGroup()\n        \n        colors = [BLUE, TEAL, GREEN, YELLOW, ORANGE, RED, PURPLE]\n        fractions = [\"1/2\", \"1/4\", \"1/8\", \"1/16\", \"1/32\", \"1/64\"]\n        \n        # 4. LOOP: Create spiral pattern\n        # Pattern: Left -> Top -> Right -> Bottom -> ... (inward spiral)\n        for i in range(7):\n            color = colors[i % len(colors)]\n            fraction_val = 1.0 / (2**(i+1))\n            sum_val += fraction_val\n            \n            # Calculate geometry based on spiral step (i % 4)\n            mode = i % 4\n            \n            if mode == 0:   # Left side of remaining\n                split_x = (x_min + x_max) / 2\n                rect = Rectangle(width=(split_x - x_min), height=(y_max - y_min))\n                rect.move_to(np.array([(x_min + split_x)/2, (y_min + y_max)/2, 0]))\n                x_min = split_x # Update remaining to be the right side\n                \n            elif mode == 1: # Top side of remaining\n                split_y = (y_min + y_max) / 2\n                rect = Rectangle(width=(x_max - x_min), height=(y_max - split_y))\n                rect.move_to(np.array([(x_min + x_max)/2, (split_y + y_max)/2, 0]))\n                y_max = split_y # Update remaining to be bottom side\n                \n            elif mode == 2: # Right side of remaining\n                split_x = (x_min + x_max) / 2\n                rect = Rectangle(width=(x_max - split_x), height=(y_max - y_min))\n                rect.move_to(np.array([(split_x + x_max)/2, (y_min + y_max)/2, 0]))\n                x_max = split_x # Update remaining to be left side\n                \n            elif mode == 3: # Bottom side of remaining\n                split_y = (y_min + y_max) / 2\n                rect = Rectangle(width=(x_max - x_min), height=(split_y - y_min))\n                rect.move_to(np.array([(x_min + x_max)/2, (y_min + split_y)/2, 0]))\n                y_min = split_y # Update remaining to be top side\n\n            # Style and Animate Rectangle\n            rect.set_stroke(WHITE, 1)\n            rect.set_fill(color, opacity=0.8)\n            pieces.add(rect)\n            \n            self.play(DrawBorderThenFill(rect), run_time=0.8)\n            \n            # Add label (only for first few big ones)\n            if i < 4:\n                lbl = Text(fractions[i], font_size=40 - (i*4))\n                lbl.move_to(rect.get_center())\n                labels.add(lbl)\n                self.play(Write(lbl), run_time=0.4)\n            \n            # Update Sum Text\n            # Format manually to avoid long decimals expanding off screen\n            if i < 5:\n                display_sum = f\"{sum_val:g}\"\n            else:\n                display_sum = f\"{sum_val:.5f}...\"\n                \n            new_sum_text = Text(f\"Sum: {display_sum}\", font_size=48).to_edge(DOWN, buff=0.5)\n            self.play(Transform(sum_text, new_sum_text), run_time=0.5)\n            \n            # Wait times decrease as shapes get smaller\n            wait_time = max(0.5, 2.0 - i * 0.3)\n            self.wait(wait_time)\n\n        # 5. REVEAL: Fill the tiny dot\n        # Visual representation of infinity filling the gap\n        final_dot = Rectangle(width=(x_max - x_min), height=(y_max - y_min))\n        final_dot.move_to(np.array([(x_min + x_max)/2, (y_min + y_max)/2, 0]))\n        final_dot.set_fill(WHITE, 1)\n        pieces.add(final_dot)\n        \n        self.play(FadeIn(final_dot, scale=0.1))\n        \n        # Message about the limit\n        limit_msg = Text(\"Approaches 1\", font_size=48).to_edge(DOWN, buff=0.5)\n        self.play(Transform(sum_text, limit_msg))\n        self.wait(2)\n\n        # 6. CONCLUDE: Morph everything into final equation\n        # Target state\n        final_equation = Text(\"Sum = 1\", font_size=80, color=YELLOW).move_to(ORIGIN)\n        \n        # Group EVERYTHING visible\n        all_visible = VGroup(title, main_square, pieces, labels, sum_text)\n        \n        # The Grand Morph\n        self.play(\n            ReplacementTransform(all_visible, final_equation),\n            run_time=2.5\n        )\n        \n        self.wait(3)",
  "estimated_duration": 65
}