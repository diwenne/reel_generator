{
  "manim_code": "class InfiniteSumProof(Scene):\n    def construct(self):\n        # 1. HOOK: Title\n        title = Text(\"Why does 1/2 + 1/4 + ... = 1?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        # Move title to top\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n\n        # 2. SETUP: The Unit Square\n        # We use a 4x4 square to represent Area = 1. Center slightly UP.\n        # Coords relative to square center: x[-2, 2], y[-2, 2]\n        # Global Center: UP * 0.5\n        sq_side = 4.0\n        sq_center = UP * 0.5\n        main_square = Square(side_length=sq_side, color=WHITE)\n        main_square.move_to(sq_center)\n\n        # Label \"Area = 1\" initially\n        area_label = Text(\"Area = 1\", font_size=48).move_to(main_square.get_center())\n        \n        self.play(Create(main_square))\n        self.play(Write(area_label))\n        self.wait(1)\n        self.play(FadeOut(area_label))\n\n        # Initialize Sum Text at bottom\n        sum_text = Text(\"Sum: 0\", font_size=48).to_edge(DOWN, buff=0.8)\n        self.play(Write(sum_text))\n\n        # 3. RECURSIVE BUILD\n        # Variables to track the \"remaining\" empty rectangle\n        # Global coordinates of the square boundaries:\n        x_min = sq_center[0] - sq_side/2  # -2.0\n        x_max = sq_center[0] + sq_side/2  # +2.0\n        y_min = sq_center[1] - sq_side/2  # -1.5\n        y_max = sq_center[1] + sq_side/2  # +2.5\n\n        current_sum_val = 0.0\n        rects_group = VGroup()  # Store all created shapes\n        labels_group = VGroup() # Store all fraction labels\n        \n        # Colors for the spiral steps\n        colors = [BLUE, TEAL, GREEN, YELLOW, GOLD, RED]\n\n        # Loop to create 1/2, 1/4, 1/8, 1/16, 1/32, 1/64\n        for i in range(1, 7):\n            fraction = 1 / (2**i)\n            current_sum_val += fraction\n            \n            # Create the rectangle for this step\n            # Logic: Alternate splitting Vertical (Left kept) vs Horizontal (Top kept)\n            if i % 2 == 1:\n                # Odd steps (1, 3, 5): Vertical Split\n                split_x = (x_min + x_max) / 2\n                new_rect_width = split_x - x_min\n                new_rect_height = y_max - y_min\n                \n                rect = Rectangle(\n                    width=new_rect_width, \n                    height=new_rect_height,\n                    color=WHITE, \n                    stroke_width=2,\n                    fill_color=colors[(i-1) % len(colors)],\n                    fill_opacity=0.8\n                )\n                # Position: Center of the left half\n                new_x = (x_min + split_x) / 2\n                new_y = (y_min + y_max) / 2\n                rect.move_to([new_x, new_y, 0])\n                \n                # Update remaining area (Right half remains)\n                x_min = split_x\n                \n            else:\n                # Even steps (2, 4, 6): Horizontal Split\n                split_y = (y_min + y_max) / 2\n                new_rect_width = x_max - x_min\n                new_rect_height = y_max - split_y\n                \n                rect = Rectangle(\n                    width=new_rect_width,\n                    height=new_rect_height,\n                    color=WHITE,\n                    stroke_width=2,\n                    fill_color=colors[(i-1) % len(colors)],\n                    fill_opacity=0.8\n                )\n                # Position: Center of the top half\n                new_x = (x_min + x_max) / 2\n                new_y = (split_y + y_max) / 2\n                rect.move_to([new_x, new_y, 0])\n                \n                # Update remaining area (Bottom half remains)\n                y_max = split_y\n\n            rects_group.add(rect)\n\n            # Add Label (only for 1/2, 1/4, 1/8 to avoid clutter)\n            if i <= 3:\n                lbl_text = f\"1/{2**i}\"\n                lbl = Text(lbl_text, font_size=40 if i < 3 else 32)\n                lbl.move_to(rect.get_center())\n                labels_group.add(lbl)\n                \n                self.play(FadeIn(rect), Write(lbl), run_time=0.8)\n            else:\n                self.play(FadeIn(rect), run_time=0.5)\n            \n            # Update Sum Text\n            # Format string to remove trailing zeros roughly\n            val_str = f\"{current_sum_val:.6g}\"\n            new_sum = Text(f\"Sum: {val_str}\", font_size=48).to_edge(DOWN, buff=0.8)\n            \n            self.play(Transform(sum_text, new_sum), run_time=0.5)\n            self.wait(0.5)\n\n        # 4. REVEAL: The Limit\n        # Flash the remaining tiny empty hole\n        hole = Rectangle(\n            width=x_max - x_min, \n            height=y_max - y_min,\n            color=YELLOW\n        ).move_to([(x_min + x_max)/2, (y_min + y_max)/2, 0])\n        \n        self.play(Create(hole))\n        self.play(FadeOut(hole))\n\n        limit_text = Text(\"Approaching 1...\", font_size=48, color=YELLOW).to_edge(DOWN, buff=0.8)\n        self.play(Transform(sum_text, limit_text))\n        self.wait(2)\n\n        # 5. CONCLUSION: Morph everything to final equation\n        final_eq = Text(\"Sum = 1\", font_size=80, color=YELLOW).move_to(ORIGIN)\n        \n        # Gather all objects currently on screen\n        # Note: sum_text is now limit_text via Transform\n        all_objects = VGroup(title, main_square, rects_group, labels_group, sum_text)\n        \n        self.play(ReplacementTransform(all_objects, final_eq), run_time=2)\n        self.wait(3)",
  "estimated_duration": 60
}