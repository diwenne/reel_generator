{
  "manim_code": "class GabrielsHorn(Scene):\n    def construct(self):\n        # 1. HOOK: Title Sequence\n        # Start at CENTER (ORIGIN)\n        title = Text(\"Infinite Surface, Finite Volume?\", font_size=56)\n        self.play(Write(title))\n        self.wait(1.5)\n        # Move title to TOP edge\n        self.play(title.animate.scale(0.7).to_edge(UP, buff=0.3))\n        self.wait(1)\n\n        # 2. FUNCTION DEFINITION (y = 1/x)\n        # Create components manually for fraction\n        y_eq = Text(\"y =\", font_size=60)\n        num = Text(\"1\", font_size=60)\n        denom = Text(\"x\", font_size=60)\n        bar = Line(start=LEFT, end=RIGHT, stroke_width=4).scale(0.5)\n        \n        # Assemble fraction\n        fraction = VGroup(num, bar, denom)\n        num.next_to(bar, UP, buff=0.1)\n        denom.next_to(bar, DOWN, buff=0.1)\n        \n        # Assemble full equation\n        equation = VGroup(y_eq, fraction).arrange(RIGHT, buff=0.4)\n        equation.move_to(ORIGIN)\n        \n        self.play(Write(equation))\n        self.wait(2)\n\n        # 3. CURVE VISUALIZATION\n        # Move equation to top-left to make room for graph\n        # We will create the graph axes and curve\n        \n        # Axes: x from 0 to 6, y from -2 to 2\n        x_axis = Arrow(start=LEFT*2, end=RIGHT*5, color=GREY)\n        y_axis = Arrow(start=DOWN*2.5, end=UP*2.5, color=GREY)\n        axes = VGroup(x_axis, y_axis).move_to(DOWN * 0.5)\n        \n        # Axis Labels\n        x_label = Text(\"x\", font_size=36).next_to(x_axis, RIGHT)\n        y_label = Text(\"y\", font_size=36).next_to(y_axis, UP)\n        labels = VGroup(x_label, y_label)\n        \n        # Move equation out of the way (fade out for cleanliness or move)\n        self.play(\n            FadeOut(equation),\n            Create(axes),\n            Write(labels)\n        )\n\n        # Draw 1/x curve from x=1 to x=5 (simulating infinity)\n        # Graph coordinates: center of axes is (0,0) relative to axes group\n        # We need to map values. Let's say 1 unit = 1 unit on screen for simplicity\n        # Origin of graph at axes.get_center() is not quite right because axes are arrows.\n        # Let's define graph origin manually.\n        graph_origin = axes.get_center() + LEFT * 1.5\n        \n        # Plot points manually to avoid GraphScene dependencies\n        # y = 1/x. Let's scale it up: screen_y = 2 * (1/x), screen_x = x\n        points_top = []\n        points_bottom = []\n        \n        for i in range(0, 51):\n            x_val = 1.0 + (i * 4.0 / 50.0)  # x goes 1 to 5\n            y_val = 1.0 / x_val\n            \n            # Map to screen coordinates\n            # Scale x by 1.2, y by 2.0 for visibility\n            px = graph_origin[0] + (x_val - 1) * 1.2  # Start x=1 at origin x\n            py_top = graph_origin[1] + y_val * 2.0\n            py_bot = graph_origin[1] - y_val * 2.0\n            \n            points_top.append([px, py_top, 0])\n            points_bottom.append([px, py_bot, 0])\n            \n        # Create curves\n        curve_top = VMobject(color=BLUE).set_points_smoothly(points_top)\n        curve_bot = VMobject(color=BLUE).set_points_smoothly(points_bottom)\n        \n        # Fill area to represent the horn\n        # Combine top and reversed bottom points to make a closed shape\n        horn_points = points_top + points_bottom[::-1]\n        horn = Polygon(*horn_points, color=BLUE, fill_opacity=0.3, stroke_width=0)\n        \n        # Draw start disk (ellipse) at x=1\n        start_x = points_top[0][0]\n        start_y_rad = (points_top[0][1] - points_top[0][1]/2) # Radius\n        # Actually simple Line is better for 2D profile, but let's use Ellipse\n        # Height is distance between top and bottom y\n        h_start = points_top[0][1] - points_bottom[0][1]\n        disk_start = Ellipse(width=0.4, height=h_start, color=WHITE).move_to([start_x, graph_origin[1], 0])\n        \n        # End disk (open end)\n        end_x = points_top[-1][0]\n        h_end = points_top[-1][1] - points_bottom[-1][1]\n        disk_end = Ellipse(width=0.2, height=h_end, color=BLUE_E).move_to([end_x, graph_origin[1], 0])\n\n        # Animate Curve\n        self.play(Create(curve_top))\n        self.wait(0.5)\n        \n        # Animate Horn formation (Rotation)\n        self.play(\n            Create(curve_bot),\n            FadeIn(horn),\n            Create(disk_start),\n            Create(disk_end)\n        )\n        \n        horn_group = VGroup(axes, labels, curve_top, curve_bot, horn, disk_start, disk_end)\n        label_horn = Text(\"Gabriel's Horn\", font_size=40).next_to(horn_group, UP)\n        self.play(Write(label_horn))\n        self.wait(2)\n\n        # 4. VOLUME CALCULUS\n        # Move horn up to make space for text\n        self.play(\n            horn_group.animate.scale(0.7).shift(UP * 1.5),\n            label_horn.animate.scale(0.7).shift(UP * 1.5),\n            FadeOut(title) # Remove title to clear top zone completely\n        )\n\n        # Volume Text Group\n        vol_title = Text(\"Volume by disks:\", font_size=36, color=BLUE).move_to(DOWN * 0.5)\n        \n        # Formula: V = pi * integral (1/x)^2 dx\n        # Using Unicode: \u222b\n        vol_formula = Text(\"V = \u03c0 \u222b\u2081\u221e (1/x)\u00b2 dx\", font_size=44).next_to(vol_title, DOWN, buff=0.3)\n        \n        # Simplify\n        vol_calc = Text(\"Integral converges to 1\", font_size=40).next_to(vol_formula, DOWN, buff=0.3)\n        \n        vol_result = Text(\"Volume = \u03c0 \u00d7 1 = \u03c0\", font_size=48, color=GREEN).next_to(vol_calc, DOWN, buff=0.4)\n        \n        self.play(Write(vol_title))\n        self.wait(1)\n        self.play(Write(vol_formula))\n        self.wait(1.5)\n        self.play(Write(vol_calc))\n        self.play(Write(vol_result))\n        self.wait(2)\n\n        # 5. SURFACE AREA CALCULUS\n        # Clear volume text\n        vol_group = VGroup(vol_title, vol_formula, vol_calc, vol_result)\n        self.play(FadeOut(vol_group))\n\n        # Area Text Group\n        area_title = Text(\"Surface Area:\", font_size=36, color=RED).move_to(DOWN * 0.5)\n        \n        # Complex formula simplified for screen width\n        # \"2\u03c0 \u222b (1/x) \u221a(1 + 1/x^4) dx\"\n        # We construct the square root manually to look good\n        \n        p1 = Text(\"A = 2\u03c0 \u222b\u2081\u221e \", font_size=40)\n        p2 = Text(\"1/x\", font_size=40)\n        p3 = Text(\"\u221a\", font_size=40)\n        p4 = Text(\"1 + 1/x\u2074\", font_size=32) # Smaller inside root\n        p5 = Text(\" dx\", font_size=40)\n        \n        # Root line\n        root_line = Line(start=p4.get_corner(UL), end=p4.get_corner(UR) + RIGHT*0.05, stroke_width=2)\n        root_line.next_to(p4, UP, buff=0.05)\n        \n        # Assemble formula line\n        # Grouping for layout\n        formula_row = VGroup(p1, p2, p3, p4, p5)\n        formula_row.arrange(RIGHT, buff=0.1, aligned_edge=DOWN)\n        # Fix root position\n        p3.next_to(p4, LEFT, buff=0.05)\n        # Re-arrange\n        formula_full = VGroup(p1, p2, p3, p4, root_line, p5)\n        formula_full.arrange(RIGHT, buff=0.1)\n        # Fix root symbol height\n        p3.shift(UP * 0.05)\n        root_line.next_to(p3, UR, buff=0).set_y(root_line.get_y())\n        \n        formula_full.next_to(area_title, DOWN, buff=0.3).set_x(0)\n\n        # Divergence explanation\n        diverge_text = Text(\"Behaves like \u222b 1/x dx\", font_size=40).next_to(formula_full, DOWN, buff=0.3)\n        diverge_res = Text(\"Harmonic series diverges!\", font_size=40).next_to(diverge_text, DOWN, buff=0.2)\n        \n        area_result = Text(\"Surface Area = \u221e\", font_size=48, color=RED).next_to(diverge_res, DOWN, buff=0.4)\n\n        self.play(Write(area_title))\n        self.play(Write(formula_full))\n        self.wait(2)\n        self.play(Write(diverge_text))\n        self.play(Write(diverge_res))\n        self.play(Write(area_result))\n        self.wait(2)\n\n        # 6. INTERPRETATION\n        # Clear Area text\n        area_group = VGroup(area_title, formula_full, diverge_text, diverge_res, area_result)\n        self.play(FadeOut(area_group))\n        \n        # Paradox statement\n        paradox = Text(\"Finite Volume, Infinite Area\", font_size=48, color=YELLOW)\n        paradox.move_to(DOWN * 1.5)\n        self.play(Write(paradox))\n        self.wait(2)\n\n        # 7. CONCLUSION\n        # Morph everything into final screen\n        # Final Title: Gabriel's Horn (Blue)\n        # Final Text: V = \u03c0, Surface Area = \u221e (Yellow)\n        \n        final_title = Text(\"Gabriel's Horn\", font_size=72, color=BLUE).move_to(UP * 0.5)\n        final_stats = Text(\"V = \u03c0,  Surface Area = \u221e\", font_size=60, color=YELLOW).next_to(final_title, DOWN, buff=0.8)\n        \n        final_group = VGroup(final_title, final_stats).move_to(ORIGIN)\n        \n        # Gather all current objects\n        all_visible = VGroup(horn_group, label_horn, paradox)\n        \n        self.play(\n            ReplacementTransform(all_visible, final_group),\n            run_time=2.0\n        )\n        \n        self.wait(4)\n",
  "estimated_duration": 50
}